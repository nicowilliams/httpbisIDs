<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en"><head profile="http://www.w3.org/2006/03/hcard"><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>RESTful Authentication Pattern for the HyperText Transport Protocol (HTTP)</title><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: #000000;
  font-family: verdana, helvetica, arial, sans-serif;
  font-size: 10pt;
}
cite {
  font-style: normal;
}
dd {
  margin-right: 2em;
}
dl {
  margin-left: 2em;
}

dl.empty dd {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  color: #333333;
  font-size: 14pt;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h1 a {
  color: #333333;
}
h2 {
  color: #000000;
  font-size: 12pt;
  line-height: 15pt;
  page-break-after: avoid;
}
h2 a {
  color: #000000;
}
h3 {
  color: #000000;
  font-size: 10pt;
  page-break-after: avoid;
}
h3 a {
  color: #000000;
}
h4 {
  color: #000000;
  font-size: 10pt;
  page-break-after: avoid;
}
h4 a {
  color: #000000;
}
h5 {
  color: #000000;
  font-size: 10pt;
  page-break-after: avoid;
}
h5 a {
  color: #000000;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
  margin-right: 2em;
}
ol {
  margin-left: 2em;
  margin-right: 2em;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
  margin-right: 2em;

}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
table {
  margin-left: 2em;
}
table.header {
  width: 95%;
  font-size: 10pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap; 
}
td.header {
  background-color: gray;
  width: 50%;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc {
  list-style: none;
  margin-left: 1.5em;
  margin-right: 0em;
  padding-left: 0em;
}
li.tocline0 {
  line-height: 150%;
  font-weight: bold;
  font-size: 10pt;
  margin-left: 0em;
  margin-right: 0em;
}
li.tocline1 {
  line-height: normal;
  font-weight: normal;
  font-size: 9pt;
  margin-left: 0em;
  margin-right: 0em;
}
li.tocline2 {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}
ul.ind {
  list-style: none;
  margin-left: 1.5em;
  margin-right: 0em;
  padding-left: 0em;
}
li.indline0 {
  font-weight: bold;
  line-height: 200%;
  margin-left: 0em;
  margin-right: 0em;
}
li.indline1 {
  font-weight: normal;
  line-height: 150%;
  margin-left: 0em;
  margin-right: 0em;
}

.comment {
  background-color: yellow;
}

.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 9pt;
}
.filename {
  color: #333333;
  font-weight: bold;
  font-size: 12pt;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.hidden {
  display: none;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: #990000;
  font-size: 18pt;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.vcardline {
  display: block;
}
.warning {
  font-size: 14pt;
  background-color: yellow;
}


@media print {
  .noprint {
    display: none;
  }
  
  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 12pt;
  }

  ul.toc a::after {
    content: leader('.') target-counter(attr(href), page);
  }
  
  a.iref {
    content: target-counter(attr(href), page);
  }
  
  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "INTERNET DRAFT"; 
  } 
  @top-right {
       content: "August 2012"; 
  } 
  @top-center {
       content: "RESTful Authentication"; 
  } 
  @bottom-left {
       content: "Williams"; 
  } 
  @bottom-center {
       content: "Informational"; 
  } 
  @bottom-right {
       content: "[Page " counter(page) "]"; 
  } 
}

@page:first { 
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}

</style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyright"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Conventions used in this document" href="#rfc.section.2"><link rel="Chapter" title="3 Protocol" href="#rfc.section.3"><link rel="Chapter" title="4 HTTP &#8220;Routing&#8221; and RESTauth" href="#rfc.section.4"><link rel="Chapter" title="5 Sample/Potential RESTauth Authentication Mechanisms" href="#rfc.section.5"><link rel="Chapter" title="6 IANA Considerations" href="#rfc.section.6"><link rel="Chapter" title="7 Security Considerations" href="#rfc.section.7"><link rel="Chapter" title="8 TODO" href="#rfc.section.8"><link rel="Chapter" href="#rfc.section.9" title="9 References"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.340, 2007/07/14 15:16:14, XSLT vendor: SAXON 9.0.0.4 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.Creator" content="Williams, N."><meta name="DC.Identifier" content="urn:ietf:id:draft-williams-http-rest-auth-00"><meta name="DC.Date.Issued" scheme="ISO8601" content="2012-08"><meta name="DC.Description.Abstract" content="This document proposes a &#8220;RESTful&#8221; pattern of authentication for HTTP/1.0, 1.1, and 2.0. The existing 401 status code and WWW-Authenticate header are used to indicate that authentication is required and for negotiation purposes. The client POSTs an initial authentication message to an indicated login URI, and reply messages are returned as new representations of a session resource named by a session URI. This approach has a number of benefits: it can be implemented with or without help from the HTTP stack, it can be universally implemented on the server side using the Common Information Gateway (CGI) and FastCGI, it results in a session Uniform Resource Identifier (URI) that can be DELETEd to logout, it is completely orthogonal to any HTTP &#8220;routers&#8221; and proxies, and it naturally (i.e., without changing HTTP) handles multi-legged authentication mechanisms. Among other features supported are: channel binding, an optional round trip optimization for challenge/response mechanisms, somecryptographic protection options for clients that don't use Transport Layer Security (TLS), stronger authentication of servers/services to users (where authentication mechanisms provide that) and more."></head><body><table summary="header information" class="header" border="0" cellpadding="1" cellspacing="1"><p class="error">

  This stylesheet requires either an XSLT-1.0 processor with node-set()
  extension function, or an XSLT-2.0 processor. Therefore, parts of the
  document couldn't be displayed.
</p></table><p class="title">RESTful Authentication Pattern for the HyperText Transport Protocol (HTTP)<br><span class="filename">draft-williams-http-rest-auth-00</span></p><p class="error">

  This stylesheet requires either an XSLT-1.0 processor with node-set()
  extension function, or an XSLT-2.0 processor. Therefore, parts of the
  document couldn't be displayed.
</p><h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1><p>This document proposes a &#8220;RESTful&#8221; pattern of authentication for HTTP/1.0, 1.1, and 2.0. The existing 401 status code and WWW-Authenticate header are used to indicate that authentication is required and for negotiation purposes. The client POSTs an initial authentication message to an indicated login URI, and reply messages are returned as new representations of a session resource named by a session URI.</p><p>This approach has a number of benefits: it can be implemented with or without help from the HTTP stack, it can be universally implemented on the server side using the Common Information Gateway (CGI) and FastCGI, it results in a session Uniform Resource Identifier (URI) that can be DELETEd to logout, it is completely orthogonal to any HTTP &#8220;routers&#8221; and proxies, and it naturally (i.e., without changing HTTP) handles multi-legged authentication mechanisms.</p><p>Among other features supported are: channel binding, an optional round trip optimization for challenge/response mechanisms, somecryptographic protection options for clients that don't use Transport Layer Security (TLS), stronger authentication of servers/services to users (where authentication mechanisms provide that) and more.</p><hr class="noprint"><h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1><ul class="toc"><li class="tocline0">1.&nbsp;&nbsp;&nbsp;<a href="#sec_Introduction">Introduction</a></li><li class="tocline0">2.&nbsp;&nbsp;&nbsp;<a href="#d1e387">Conventions used in this document</a></li><li class="tocline0">3.&nbsp;&nbsp;&nbsp;<a href="#sec_Protocol">Protocol</a><ul class="toc"><li class="tocline1">3.1&nbsp;&nbsp;&nbsp;<a href="#sub_Negotiable_Parameters">Negotiable Parameters</a><ul class="toc"><li class="tocline1">3.1.1&nbsp;&nbsp;&nbsp;<a href="#sub_WWW_Authenticate_Header_Value">WWW-Authenticate Header Value Prefix Syntax</a></li><li class="tocline1">3.1.2&nbsp;&nbsp;&nbsp;<a href="#sub_WWW_ChannelBinding_Types_Header">WWW-ChannelBinding-Types Header</a></li><li class="tocline1">3.1.3&nbsp;&nbsp;&nbsp;<a href="#sub_WWW_ChannelBinding_Type_Header">WWW-ChannelBinding-Type Header</a></li><li class="tocline1">3.1.4&nbsp;&nbsp;&nbsp;<a href="#sub_WWW_SessionType_Header">WWW-SessionType Header</a></li><li class="tocline1">3.1.5&nbsp;&nbsp;&nbsp;<a href="#sub_WWW_ReplayProtection_Header">WWW-ReplayProtection Header</a></li></ul></li><li class="tocline1">3.2&nbsp;&nbsp;&nbsp;<a href="#sub_Protocol_Flow">Protocol Flow</a><ul class="toc"><li class="tocline1">3.2.1&nbsp;&nbsp;&nbsp;<a href="#sub_One_Round_Trip">One Round Trip Optimization: Challenges Born in WWW-Authenticate Headers</a></li></ul></li><li class="tocline1">3.3&nbsp;&nbsp;&nbsp;<a href="#sub_Session_Binding_Types_">Session Binding Types: Cookie, URI, and MAC</a><ul class="toc"><li class="tocline1">3.3.1&nbsp;&nbsp;&nbsp;<a href="#sub_The_New_WWW_Session_URI">The New WWW-Session-URI Header</a></li><li class="tocline1">3.3.2&nbsp;&nbsp;&nbsp;<a href="#sub_The_New_WWW_Session_MAC">The New WWW-Session-MAC Header</a></li><li class="tocline1">3.3.3&nbsp;&nbsp;&nbsp;<a href="#sub_A_MAC_Trailer__">A MAC Trailer??</a></li></ul></li></ul></li><li class="tocline0">4.&nbsp;&nbsp;&nbsp;<a href="#sec_HTTP_Routing_and">HTTP &#8220;Routing&#8221; and RESTauth</a></li><li class="tocline0">5.&nbsp;&nbsp;&nbsp;<a href="#d1e710">Sample/Potential RESTauth Authentication Mechanisms</a><ul class="toc"><li class="tocline1">5.1&nbsp;&nbsp;&nbsp;<a href="#d1e719">Adapting SSHv2 Authentication Mechanisms to RESTauth</a><ul class="toc"><li class="tocline1">5.1.1&nbsp;&nbsp;&nbsp;<a href="#d1e725">Adaptinve SSHv2 'publickey userauth' to RESTauth</a></li><li class="tocline1">5.1.2&nbsp;&nbsp;&nbsp;<a href="#d1e731">Adaptinve SSHv2 'hostbased userauth' to RESTauth</a></li></ul></li><li class="tocline1">5.2&nbsp;&nbsp;&nbsp;<a href="#d1e737">Adapting IKEv2 Authentication Mechanisms to RESTauth</a><ul class="toc"><li class="tocline1">5.2.1&nbsp;&nbsp;&nbsp;<a href="#d1e743">Adaptinve IKEv2 Password Authenticated Connection Establishment (PACE) to RESTauth</a></li></ul></li><li class="tocline1">5.3&nbsp;&nbsp;&nbsp;<a href="#d1e750">Using SASL Authentication Mechanisms with RESTauth</a><ul class="toc"><li class="tocline1">5.3.1&nbsp;&nbsp;&nbsp;<a href="#d1e756">Using SCRAM in RESTauth</a></li><li class="tocline1">5.3.2&nbsp;&nbsp;&nbsp;<a href="#d1e762">Using SCRAM with Round Trip Optimization in RESTauth</a></li></ul></li><li class="tocline1">5.4&nbsp;&nbsp;&nbsp;<a href="#d1e768">Using GSS-API Authentication Mechanisms with RESTauth</a></li></ul></li><li class="tocline0">6.&nbsp;&nbsp;&nbsp;<a href="#sec_IANA_Considerations">IANA Considerations</a></li><li class="tocline0">7.&nbsp;&nbsp;&nbsp;<a href="#sec_Security_Considerations">Security Considerations</a></li><li class="tocline0">8.&nbsp;&nbsp;&nbsp;<a href="#d1e796">TODO</a></li><li class="tocline0">9.&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a></li><li class="tocline0"><a href="#rfc.authors">Author's Address</a></li><li class="tocline0"><a href="#rfc.ipr">Intellectual Property and Copyright Statements</a></li></ul><ul class="toc"><li class="tocline0"><a href="#rfc.figure.1">Figure 1: </a></li></ul><hr class="noprint"><h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a id="sec_Introduction" href="#sec_Introduction">Introduction</a></h1><p id="rfc.section.1.p.1">We propose a pattern for HTTP authentication mechanisms that, by being &#8220;RESTful&#8221;, obtains a number of benefits:</p><p id="rfc.section.1.p.2"> </p><ul><li>compatibility with &#8220;HTTP routing&#8221; by making no assumptions that related requests are sent over the same TCP/TLS connection;</li><li>a &#8220;session URI&#8221; results that can be used to multiplex multiple sessions onto the same TCP/TLS connections;</li><li>a &#8220;session URI&#8221; results that can be DELETEd to effect logout;</li><li>a &#8220;session URI&#8221; results that has better security semantics than web cookies;</li><li>the ability to refer to multiple sessions in one request wherever such a concept might be useful;</li><li>can be implemented by any application without changes being required to any HTTP stack;</li><li>can be implemented by the HTTP stack;</li><li>on the server side this can be implemented entirely via CGI and FastCGI;</li><li>by its RESTful nature, multi-legged authentication message exchanges are naturally handled without making any changes to HTTP.</li></ul><p id="rfc.section.1.p.3">There are probably other benefits not listed above.</p><p id="rfc.section.1.p.4">The rough outline of the protocol is quite simple: initial authentication messages are POSTed to an agreed-upon or indicated resource, which then results in a new resource being created with the authentication reply message as the new resource's representation. Thereafter any additional authentication message exchanges needed (for multi-legged mechanisms) are POSTed to the new resource without a new resource being created. The resource created by the POSTing of the initial authentication mechanism identifies the resulting session, and its URI is known as the session URI. Session URIs can be used to multiplex multiple sessions over the same TCP/TLS connections, implement logout, and share sessions across multiple related servers.</p><p id="rfc.section.1.p.5">Server-initiated authentication is also possible, whereby the server sends a challenge (not much else can be sent of value in an initial authentication message from the server besides a challenge, negotiation parameters, and, perhaps, a digital signature) in 401 errors in headers. If the server gives the client has a choice of mechanisms and the client picks one where the server sent the initial authentication message, then the client consumes that message and POSTs subsequent ones to the agreed URI.</p><p id="rfc.section.1.p.6">This document replaces <a href="#I-D.williams-rest-gss"><cite title="RESTful Hypertext Transfer Protocol Application-Layer Authentication Using Generic Security Services">[I-D.williams-rest-gss]</cite></a>.</p><hr class="noprint"><h1 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a id="d1e387" href="#d1e387">Conventions used in this document</a></h1><p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p><hr class="noprint"><h1 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a>&nbsp;<a id="sec_Protocol" href="#sec_Protocol">Protocol</a></h1><p id="rfc.section.3.p.1">The are very few normative protocol elements here besides the outline given in <a href="#sec_Introduction" title="Introduction">Section&nbsp;1</a>. The normative protocol elements are:</p><p id="rfc.section.3.p.2"> </p><ul><li>the form of the WWW-Authenticate header values for RESTauth mechanisms;</li><li>several new headers for advertising negotiable paramters that are orthogonal to WWW-Authenticate;</li><li>the POSTing of authentication messages from the client, with the initial client authentication message going to either a pre-agreed URI or to a URI named in the WWW-Authenticate headers;</li><li>the creation of a session URI as a result of the initial POST, and the subsequent POSTing of any additional authentication messages to the session URI;</li><li>the new session URI resource representation resulting from POSTs being the server's response authentication message, if any;</li><li>the DELETEion of session URIs as signalling logout;</li><li>a new header for referencing session URIs in normal HTTP requests;</li><li>the use of channel binding to TLS for session protection;</li><li>the use of session keys as an option for integrity protection when TLS is not used.</li></ul><h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;<a id="sub_Negotiable_Parameters" href="#sub_Negotiable_Parameters">Negotiable Parameters</a></h2><p id="rfc.section.3.1.p.1">As can be seen in the ABNF in the preceding section, the server can offer some negotiable parameters. These are:</p><p id="rfc.section.3.1.p.2"> </p><ul><li>Mechanism names;</li><li>Channel binding types;</li><li>Session binding types;</li><li>Replay protection;</li></ul><p id="rfc.section.3.1.p.3">Each WWW-Authenticate header value offers a single mechanism and negotiable parameters for it. The WWW-ChannelBinding-Types header allows the server to offer channel binding types.</p><h3 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1</a>&nbsp;<a id="sub_WWW_Authenticate_Header_Value" href="#sub_WWW_Authenticate_Header_Value">WWW-Authenticate Header Value Prefix Syntax</a></h3><p id="rfc.section.3.1.1.p.1">The ABNF for RESTauth WWW-Authenticate header values is as follows:</p><p id="rfc.section.3.1.1.p.3"> </p><div id="fig_WWW_Authenticate_ABNF"></div><div id="rfc.figure.1"></div><pre>      challenge           = ( "RA-" mechname SP restauth-challenge )
      mechname            = TBD
      restauth-challenge  = ( login-uri SP session-types SP
                              replay-prot SP *1(mech-challenge) )
      login-uri           = absoluteURI
      session-types       = "s=" session-type /
                            (session-type ":" session-types)
      session-type        = "cookie" / "session-ID" / "MAC"
      replay-prot         = "r=" ("yes" / "no")
      ; TODO: add production for
      ;       mech-challenge as a base64 string
      ; TODO: add MAC algorithm offers for alg agility</pre><p>Figure 1: WWW-Authenticate ABNF</p><p class="figure">Figure 1</p><p id="rfc.section.3.1.1.p.4">For a DIGEST-like mechanism it might look like &#8220;WWW-Authenticate: RA-Digest-SHA-256 tls-server-end-point session-ID no HE4SgWGrd/3+O7t16HqusA==&#8221;. For example, the mechname for the Kerberos V5 GSS-API mechanism might be &#8220;gss-krb5&#8221;, and a WWW-Authenticate header value for it might look like &#8220;WWW-Authenticate: RA-gss-krb5 http://foo.example/restauth-login tls-server-end-point session-ID no&#8221;.</p><p id="rfc.section.3.1.1.p.5">Note that mechanisms that may be used include: GSS mechanisms, SASL mechanisms, ad-hoc mechanisms, and so on.</p><h3 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2</a>&nbsp;<a id="sub_WWW_ChannelBinding_Types_Header" href="#sub_WWW_ChannelBinding_Types_Header">WWW-ChannelBinding-Types Header</a></h3><p id="rfc.section.3.1.2.p.1">A new header is added by which servers MUST indicate which channel binding <a href="#RFC5056"><cite title="On the Use of Channel Bindings to Secure Channels">[RFC5056]</cite></a> types -if any- they support for RESTauth authentication; if the server does not support channel binding then this header MUST be absent. The header is named WWW-ChannelBinding-Types. Its values are channel binding types from the channel binding type registry <a href="#RFC5929"><cite title="Channel Bindings for TLS">[RFC5929]</cite></a>.</p><h3 id="rfc.section.3.1.3"><a href="#rfc.section.3.1.3">3.1.3</a>&nbsp;<a id="sub_WWW_ChannelBinding_Type_Header" href="#sub_WWW_ChannelBinding_Type_Header">WWW-ChannelBinding-Type Header</a></h3><p id="rfc.section.3.1.3.p.1">A new header is added by which clients MUST indicate what channel binding type they used when POSTing RESTauth authentication messages, if any; if the client did not use channel binding then this header MUST be absent. The header is named WWW-ChannelBinding-Type. Its value is a channel binding type from the channel binding type registry <a href="#RFC5929"><cite title="Channel Bindings for TLS">[RFC5929]</cite></a>.</p><h3 id="rfc.section.3.1.4"><a href="#rfc.section.3.1.4">3.1.4</a>&nbsp;<a id="sub_WWW_SessionType_Header" href="#sub_WWW_SessionType_Header">WWW-SessionType Header</a></h3><p id="rfc.section.3.1.4.p.1">A new header is added by which clients MUST indicate what session binding type they choose when POSTing RESTauth authentication messages. The header is named WWW-SessionBinding-Type. Its value is a session binding type as shown in <a href="#fig_WWW_Authenticate_ABNF">Figure&nbsp;1</a>. This header MUST be present in RESTauth authentication HTTP requests.</p><h3 id="rfc.section.3.1.5"><a href="#rfc.section.3.1.5">3.1.5</a>&nbsp;<a id="sub_WWW_ReplayProtection_Header" href="#sub_WWW_ReplayProtection_Header">WWW-ReplayProtection Header</a></h3><p id="rfc.section.3.1.5.p.1">A new header is added by which clients MUST indicate whether they desire replay protection when POSTing RESTauth authentication messages. The header is named WWW-SessionBinding-Type. Its value is &#8220;yes&#8221; or &#8220;no&#8221; (defaults to &#8220;no&#8221; if absent) as shown in <a href="#fig_WWW_Authenticate_ABNF">Figure&nbsp;1</a>.</p><p id="rfc.section.3.1.5.p.2">Replay protection is to be used only when TLS <a href="#RFC5246"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[RFC5246]</cite></a> is not, and only if a session binding type of &#8220;MAC&#8221; is also requested.</p><h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a id="sub_Protocol_Flow" href="#sub_Protocol_Flow">Protocol Flow</a></h2><p id="rfc.section.3.2.p.1">RESTauth can be initiated by a client that knows a priori that it needs to or wants to use RESTauth. Servers can also tell clients that access to certain resources require authentication, possibly including RESTauth mechanisms. When the server tells the client that it must authenticate the server may also give the client an initial authentication message for one or more mechanisms.</p><p id="rfc.section.3.2.p.2">When the client knows a priori that it must authenticate then the client MUST know the RESTauth login URI a priori as well, as well as negotiable parameters, all of which the client might know from either an application protocol specification, or from caching this information from earlier RESTauth exchanges.</p><p id="rfc.section.3.2.p.3">The server MUST use a 401 HTTP status code and WWW-Authenticate headers to inform the client of the need to authenticate in order to access a given resource. For RESTauth mechanisms the WWW-Authenticate header values MUST conform to the ABNF given in <a href="#sub_WWW_Authenticate_Header_Value" title="WWW-Authenticate Header Value Prefix Syntax">Section&nbsp;3.1.1</a>.</p><p id="rfc.section.3.2.p.4">To proceed the client chooses a suitable authentication mechanism (for which, presumably, it has credentials for a desired client identity), possibly a channel binding type, possibly a session type, and whether to use replay protection.</p><h3 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;<a id="sub_One_Round_Trip" href="#sub_One_Round_Trip">One Round Trip Optimization: Challenges Born in WWW-Authenticate Headers</a></h3><p id="rfc.section.3.2.1.p.1">Some mechanisms may optimize the protocol flow by allowing the server to include challenges in the 401 response's WWW-Authenticate header values. RESTauth allows this, but this feature is OPTIONAL: it must always be possible for a client to initiate RESTauth without first obtaining a challenge in a WWW-Authenticate header value, in which case the client must incur an extra protocol leg by obtaining the challenge (if it is at all necessary) in the server's reply to the client's first authentication message. The reason that this optimization is optional is to allow the implementation of RESTauth mechanisms with frameworks that only support client-initiated authentication.</p><p id="rfc.section.3.2.1.p.2">A challenge may consist of a nonce, some encrypted or MACed nonce, a timestamp, and even seemingly unrelated contents such as certificates and digital signatures. The server MAY include a login URI in challenge-laden WWW-Authenticate headers where the login URI encodes secure state regarding the challenge.</p><h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;<a id="sub_Session_Binding_Types_" href="#sub_Session_Binding_Types_">Session Binding Types: Cookie, URI, and MAC</a></h2><p id="rfc.section.3.3.p.1">A notion of session binding type is added for binding HTTP requests to specific RESTauth login sessions. Three types are provided:</p><p id="rfc.section.3.3.p.2"> </p><dl><dt>Cookies</dt><dd>The traditional web cookie approach to session binding;</dd><dt>Session&nbsp;URI</dt><dd>HTTP requests carry a WWW-Session-URI header identifying the session(s) (similar to cookies, but without all the associated baggage);</dd><dt>MAC</dt><dd>HTTP requests carry a WWW-Session-URI header identifying the session(s) and a WWW-Session-MAC header that carries a MAC or MACs binding the session URI(s) to the request.</dd></dl><h3 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1</a>&nbsp;<a id="sub_The_New_WWW_Session_URI" href="#sub_The_New_WWW_Session_URI">The New WWW-Session-URI Header</a></h3><p id="rfc.section.3.3.1.p.1">A new HTTP header is added called WWW-Session-URI whose values consist of session URIs. At least one session URI MUST be included. Each session URI is an absoluteURI. Session URIs MUST NOT have unescaped commas (',') embedded in them. Servers MAY fail to implement support for multiple session URIs being referenced by a single request, in which case they MUST answer with error code &lt;TBD&gt;. Servers MUST validate the session URI before processing the request; if the session URI is invalid the server MUST respond with a 401 (or TBD?) status code.</p><h3 id="rfc.section.3.3.2"><a href="#rfc.section.3.3.2">3.3.2</a>&nbsp;<a id="sub_The_New_WWW_Session_MAC" href="#sub_The_New_WWW_Session_MAC">The New WWW-Session-MAC Header</a></h3><p id="rfc.section.3.3.2.p.1"> <span class="comment">[rfc.comment.1: 
Describe the header, its values, algorithm agility, and what the MAC is to be taken over. Note too that this cannot apply to request contents as we have to consider chunking, and besides, a MAC of contents really has to go as a trailer, not a header.]</span> </p><h3 id="rfc.section.3.3.3"><a href="#rfc.section.3.3.3">3.3.3</a>&nbsp;<a id="sub_A_MAC_Trailer__" href="#sub_A_MAC_Trailer__">A MAC Trailer??</a></h3><p id="rfc.section.3.3.3.p.1"> <span class="comment">[rfc.comment.2: 
...]</span> </p><hr class="noprint"><h1 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a>&nbsp;<a id="sec_HTTP_Routing_and" href="#sec_HTTP_Routing_and">HTTP &#8220;Routing&#8221; and RESTauth</a></h1><p id="rfc.section.4.p.1">It is common to deploy HTTP services with load-balanced servers behind a load balancer and TLS concentrator. Other techniques may also result in a multiplicity of servers acting on behalf of a single service. The load balancers may even behave like routers and route HTTP requests to the same server for all requests in a single connection, or even route HTTP requests according to the verb and resource. It helps to be able to have a notion of authenticated sessions that can be referenced by all servers responding to a given service name.</p><p id="rfc.section.4.p.2">The server end of a RESTauth authentication message exchange may be terminated by one server, by many servers sharing session state (via the resources named by session URIs), or by a server-side HTTP router. Once a RESTauth session is established we assume that all servers responding to the same service name will be able to access the session resource, validate session URIs, and obtain keys for computing and validating session binding MACs. Alternatively, the router may take responsibility for session binding and signal authorization information from the established session to the HTTP servers behind the router (however, we do not here specify any methods for such signalling).</p><p id="rfc.section.4.p.3">By using REST for the authentication message exchange we allow this disconnection between &#8220;session&#8221; and &#8220;connection&#8221;, which therefore facilitates &#8220;routing&#8221; of HTTP requests and even off-loading of authentication and/or session binding to HTTP &#8220;routers&#8221;.</p><p id="rfc.section.4.p.4">This approach should be flexible enough for all existing architectures for deploying HTTP services.</p><hr class="noprint"><h1 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a>&nbsp;<a id="d1e710" href="#d1e710">Sample/Potential RESTauth Authentication Mechanisms</a></h1><p id="rfc.section.5.p.1"> <span class="comment">[rfc.comment.3: 
TODO: Describe how to use or adapt a variety of authentication mechanisms, from SSHv2, IKEv2, SASL, GSS-API, and other frameworks, to gain a set of usable mechanisms quickly, both, specification- and implementation-wise. Although I've not done this yet, it seems likely to be quite simple to adapt all these authentication mechanism types to RESTauth.]</span> </p><h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1</a>&nbsp;<a id="d1e719" href="#d1e719">Adapting SSHv2 Authentication Mechanisms to RESTauth</a></h2><h3 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1</a>&nbsp;<a id="d1e725" href="#d1e725">Adaptinve SSHv2 'publickey userauth' to RESTauth</a></h3><h3 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2</a>&nbsp;<a id="d1e731" href="#d1e731">Adaptinve SSHv2 'hostbased userauth' to RESTauth</a></h3><h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2</a>&nbsp;<a id="d1e737" href="#d1e737">Adapting IKEv2 Authentication Mechanisms to RESTauth</a></h2><h3 id="rfc.section.5.2.1"><a href="#rfc.section.5.2.1">5.2.1</a>&nbsp;<a id="d1e743" href="#d1e743">Adaptinve IKEv2 Password Authenticated Connection Establishment (PACE) to RESTauth</a></h3><h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3</a>&nbsp;<a id="d1e750" href="#d1e750">Using SASL Authentication Mechanisms with RESTauth</a></h2><h3 id="rfc.section.5.3.1"><a href="#rfc.section.5.3.1">5.3.1</a>&nbsp;<a id="d1e756" href="#d1e756">Using SCRAM in RESTauth</a></h3><h3 id="rfc.section.5.3.2"><a href="#rfc.section.5.3.2">5.3.2</a>&nbsp;<a id="d1e762" href="#d1e762">Using SCRAM with Round Trip Optimization in RESTauth</a></h3><h2 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4</a>&nbsp;<a id="d1e768" href="#d1e768">Using GSS-API Authentication Mechanisms with RESTauth</a></h2><hr class="noprint"><h1 id="rfc.section.6" class="np"><a href="#rfc.section.6">6.</a>&nbsp;<a id="sec_IANA_Considerations" href="#sec_IANA_Considerations">IANA Considerations</a></h1><p id="rfc.section.6.p.1">TBD (header registrations, ...)</p><hr class="noprint"><h1 id="rfc.section.7" class="np"><a href="#rfc.section.7">7.</a>&nbsp;<a id="sec_Security_Considerations" href="#sec_Security_Considerations">Security Considerations</a></h1><p id="rfc.section.7.p.1">This entire document deals with security considerations. [Add more, like about channel binding, same-origin-like constraints on the login and session absolute URIs', ...]</p><hr class="noprint"><h1 id="rfc.section.8" class="np"><a href="#rfc.section.8">8.</a>&nbsp;<a id="d1e796" href="#d1e796">TODO</a></h1><p id="rfc.section.8.p.1"> <span class="comment">[rfc.comment.4: 
Add references (to HTTP, CGI/fCGI, SSHv2, IKEv2, SASL, GSS, PACE, ...).]</span> </p><p id="rfc.section.8.p.2"> <span class="comment">[rfc.comment.5: 
Describe MAC session binding option and replay protection in detail.]</span> </p><p id="rfc.section.8.p.3"> <span class="comment">[rfc.comment.6: 
Add text to and complete sections describing how to use various existing security mechanisms with RESTauth, such as SASL, GSS-API, and other mechanisms.]</span> </p><p id="rfc.section.8.p.4"> <span class="comment">[rfc.comment.7: 
Add text to and complete sections describing mechanisms for adapting to RESTauth SSHv2 publickey, SSHv2 host-based authentication, IKEv2 methods, and other such authentication mechanisms as a way of showcasing RESTauth.]</span> </p><h1 class="np" id="rfc.references"><a href="#rfc.section.9" id="rfc.section.9">9.</a> References</h1><table summary="References"><tr><td class="reference"><b id="RFC2119">[RFC2119]</b></td><td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>&#8221;, BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.</td></tr><tr><td class="reference"><b id="RFC5246">[RFC5246]</b></td><td class="top">Dierks, T. and E. Rescorla, &#8220;<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>&#8221;, RFC&nbsp;5246, August&nbsp;2008.</td></tr><tr><td class="reference"><b id="RFC5056">[RFC5056]</b></td><td class="top">Williams, N., &#8220;<a href="http://tools.ietf.org/html/rfc5056">On the Use of Channel Bindings to Secure Channels</a>&#8221;, RFC&nbsp;5056, November&nbsp;2007.</td></tr><tr><td class="reference"><b id="RFC5929">[RFC5929]</b></td><td class="top">Altman, J., Williams, N., and L. Zhu, &#8220;<a href="http://tools.ietf.org/html/rfc5929">Channel Bindings for TLS</a>&#8221;, RFC&nbsp;5929, July&nbsp;2010.</td></tr><tr><td class="reference"><b id="I-D.williams-rest-gss">[I-D.williams-rest-gss]</b></td><td class="top">Williams, N., &#8220;<a href="http://tools.ietf.org/html/draft-williams-rest-gss-02">RESTful Hypertext Transfer Protocol Application-Layer Authentication Using Generic Security Services</a>&#8221;, Internet-Draft&nbsp;draft-williams-rest-gss-02 (work in progress), July&nbsp;2012.</td></tr></table><hr class="noprint"><h1 id="rfc.authors" class="np"><a href="#rfc.authors">Author's Address</a></h1><address class="vcard"><span class="vcardline"><span class="fn">Nicolas Williams</span><span class="n hidden"><span class="family-name">Williams</span><span class="given-name">Nicolas</span></span></span><span class="org vcardline">Cryptonector, LLC</span><span class="vcardline">EMail: <a href="mailto:nico@cryptonector.com"><span class="email">nico@cryptonector.com</span></a></span></address><p class="error">

  This stylesheet requires either an XSLT-1.0 processor with node-set()
  extension function, or an XSLT-2.0 processor. Therefore, parts of the
  document couldn't be displayed.
</p></body></html>