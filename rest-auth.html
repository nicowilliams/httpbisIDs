<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en"><head profile="http://www.w3.org/2006/03/hcard"><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>RESTful Authentication Pattern for the Hypertext Transport Protocol (HTTP)</title><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: #000000;
  font-family: verdana, helvetica, arial, sans-serif;
  font-size: 10pt;
}
cite {
  font-style: normal;
}
dd {
  margin-right: 2em;
}
dl {
  margin-left: 2em;
}

dl.empty dd {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  color: #333333;
  font-size: 14pt;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h1 a {
  color: #333333;
}
h2 {
  color: #000000;
  font-size: 12pt;
  line-height: 15pt;
  page-break-after: avoid;
}
h2 a {
  color: #000000;
}
h3 {
  color: #000000;
  font-size: 10pt;
  page-break-after: avoid;
}
h3 a {
  color: #000000;
}
h4 {
  color: #000000;
  font-size: 10pt;
  page-break-after: avoid;
}
h4 a {
  color: #000000;
}
h5 {
  color: #000000;
  font-size: 10pt;
  page-break-after: avoid;
}
h5 a {
  color: #000000;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
  margin-right: 2em;
}
ol {
  margin-left: 2em;
  margin-right: 2em;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
  margin-right: 2em;

}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
table {
  margin-left: 2em;
}
table.header {
  width: 95%;
  font-size: 10pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap; 
}
td.header {
  background-color: gray;
  width: 50%;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc {
  list-style: none;
  margin-left: 1.5em;
  margin-right: 0em;
  padding-left: 0em;
}
li.tocline0 {
  line-height: 150%;
  font-weight: bold;
  font-size: 10pt;
  margin-left: 0em;
  margin-right: 0em;
}
li.tocline1 {
  line-height: normal;
  font-weight: normal;
  font-size: 9pt;
  margin-left: 0em;
  margin-right: 0em;
}
li.tocline2 {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}
ul.ind {
  list-style: none;
  margin-left: 1.5em;
  margin-right: 0em;
  padding-left: 0em;
}
li.indline0 {
  font-weight: bold;
  line-height: 200%;
  margin-left: 0em;
  margin-right: 0em;
}
li.indline1 {
  font-weight: normal;
  line-height: 150%;
  margin-left: 0em;
  margin-right: 0em;
}

.comment {
  background-color: yellow;
}

.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 9pt;
}
.filename {
  color: #333333;
  font-weight: bold;
  font-size: 12pt;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.hidden {
  display: none;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: #990000;
  font-size: 18pt;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.vcardline {
  display: block;
}
.warning {
  font-size: 14pt;
  background-color: yellow;
}


@media print {
  .noprint {
    display: none;
  }
  
  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 12pt;
  }

  ul.toc a::after {
    content: leader('.') target-counter(attr(href), page);
  }
  
  a.iref {
    content: target-counter(attr(href), page);
  }
  
  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "INTERNET DRAFT"; 
  } 
  @top-right {
       content: "August 2012"; 
  } 
  @top-center {
       content: "RESTful Authentication"; 
  } 
  @bottom-left {
       content: "Williams"; 
  } 
  @bottom-center {
       content: "Informational"; 
  } 
  @bottom-right {
       content: "[Page " counter(page) "]"; 
  } 
}

@page:first { 
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}

</style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyright"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Conventions used in this document" href="#rfc.section.2"><link rel="Chapter" title="3 API-Imposed Constraints" href="#rfc.section.3"><link rel="Chapter" title="4 Protocol" href="#rfc.section.4"><link rel="Chapter" title="5 HTTP &#8220;Routing&#8221; and Authentication" href="#rfc.section.5"><link rel="Chapter" title="6 In-band HTTP Authentication Alternatives" href="#rfc.section.6"><link rel="Chapter" title="7 Sample/Potential RESTauth Authentication Mechanisms" href="#rfc.section.7"><link rel="Chapter" title="8 IANA Considerations" href="#rfc.section.8"><link rel="Chapter" title="9 Security Considerations" href="#rfc.section.9"><link rel="Chapter" title="10 TODO" href="#rfc.section.10"><link rel="Chapter" href="#rfc.section.11" title="11 References"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.340, 2007/07/14 15:16:14, XSLT vendor: SAXON 9.0.0.4 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.Creator" content="Williams, N."><meta name="DC.Identifier" content="urn:ietf:id:draft-williams-http-rest-auth-04"><meta name="DC.Date.Issued" scheme="ISO8601" content="2012-08"><meta name="DC.Description.Abstract" content="This document proposes a &#8220;RESTful&#8221; pattern of authentication for HTTP/1.0, 1.1, and 2.0. The goal is to make it easy to add authentication mechanisms to HTTP and to make it easy to implement them even without much help from the HTTP stack (though it is best to integrate authentication into the stack, of course). Among other benefits of RESTauth: it is orthogonal to &#8220;HTTP routers&#8221; and proxies, it results in session Uniform Resource Identifiers (URIs) that can be DELETEd to logout, naturally supports multi-legged authentication schemes, and it can be universally implemented on the server side with the Common Gateway Interface (CGI) and FastCGI."></head><body><table summary="header information" class="header" border="0" cellpadding="1" cellspacing="1"><p class="error">

  This stylesheet requires either an XSLT-1.0 processor with node-set()
  extension function, or an XSLT-2.0 processor. Therefore, parts of the
  document couldn't be displayed.
</p></table><p class="title">RESTful Authentication Pattern for the Hypertext Transport Protocol (HTTP)<br><span class="filename">draft-williams-http-rest-auth-04</span></p><p class="error">

  This stylesheet requires either an XSLT-1.0 processor with node-set()
  extension function, or an XSLT-2.0 processor. Therefore, parts of the
  document couldn't be displayed.
</p><h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1><p>This document proposes a &#8220;RESTful&#8221; pattern of authentication for HTTP/1.0, 1.1, and 2.0. The goal is to make it easy to add authentication mechanisms to HTTP and to make it easy to implement them even without much help from the HTTP stack (though it is best to integrate authentication into the stack, of course).</p><p>Among other benefits of RESTauth: it is orthogonal to &#8220;HTTP routers&#8221; and proxies, it results in session Uniform Resource Identifiers (URIs) that can be DELETEd to logout, naturally supports multi-legged authentication schemes, and it can be universally implemented on the server side with the Common Gateway Interface (CGI) and FastCGI.</p><hr class="noprint"><h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1><ul class="toc"><li class="tocline0">1.&nbsp;&nbsp;&nbsp;<a href="#sec_Introduction">Introduction</a></li><li class="tocline0">2.&nbsp;&nbsp;&nbsp;<a href="#d1e458">Conventions used in this document</a></li><li class="tocline0">3.&nbsp;&nbsp;&nbsp;<a href="#d1e473">API-Imposed Constraints</a></li><li class="tocline0">4.&nbsp;&nbsp;&nbsp;<a href="#sec_Protocol">Protocol</a><ul class="toc"><li class="tocline1">4.1&nbsp;&nbsp;&nbsp;<a href="#sub_Negotiable_Parameters">Negotiable Parameters</a><ul class="toc"><li class="tocline1">4.1.1&nbsp;&nbsp;&nbsp;<a href="#d1e588">Strong Binding to TLS</a></li><li class="tocline1">4.1.2&nbsp;&nbsp;&nbsp;<a href="#sub_WWW_Authenticate_Header_Value">WWW-Authenticate Header Value Prefix Syntax</a></li><li class="tocline1">4.1.3&nbsp;&nbsp;&nbsp;<a href="#sub_WWW_ChannelBinding_Types_Header">WWW-ChannelBinding-Types Header</a></li><li class="tocline1">4.1.4&nbsp;&nbsp;&nbsp;<a href="#sub_WWW_ChannelBinding_Type_Header">WWW-ChannelBinding-Type Header</a></li><li class="tocline1">4.1.5&nbsp;&nbsp;&nbsp;<a href="#sub_WWW_SessionType_Header">WWW-SessionBinding-Type Header</a></li><li class="tocline1">4.1.6&nbsp;&nbsp;&nbsp;<a href="#sub_WWW_ReplayProtection_Header">WWW-ReplayProtection Header</a></li></ul></li><li class="tocline1">4.2&nbsp;&nbsp;&nbsp;<a href="#sub_Protocol_Flow">Protocol Flow</a><ul class="toc"><li class="tocline1">4.2.1&nbsp;&nbsp;&nbsp;<a href="#sub_One_Round_Trip">One Round Trip Optimization: Challenges Born in WWW-Authenticate Headers</a></li></ul></li><li class="tocline1">4.3&nbsp;&nbsp;&nbsp;<a href="#sub_Session_Binding_Types_">Session Binding Types: Cookie, URI, and MAC</a><ul class="toc"><li class="tocline1">4.3.1&nbsp;&nbsp;&nbsp;<a href="#sub_The_New_WWW_Session_URI">The New WWW-Session-URI Header</a></li><li class="tocline1">4.3.2&nbsp;&nbsp;&nbsp;<a href="#sub_The_New_WWW_Session_MAC">The New WWW-Session-MAC Header</a></li><li class="tocline1">4.3.3&nbsp;&nbsp;&nbsp;<a href="#sub_A_MAC_Trailer__">A MAC Trailer??</a></li></ul></li></ul></li><li class="tocline0">5.&nbsp;&nbsp;&nbsp;<a href="#sec_HTTP_Routing_and">HTTP &#8220;Routing&#8221; and Authentication</a></li><li class="tocline0">6.&nbsp;&nbsp;&nbsp;<a href="#d1e858">In-band HTTP Authentication Alternatives</a></li><li class="tocline0">7.&nbsp;&nbsp;&nbsp;<a href="#sec_Sample_Potential_RESTauth_Authen">Sample/Potential RESTauth Authentication Mechanisms</a><ul class="toc"><li class="tocline1">7.1&nbsp;&nbsp;&nbsp;<a href="#sub_OAuth_via_RESTauth">OAuth via RESTauth</a><ul class="toc"><li class="tocline1">7.1.1&nbsp;&nbsp;&nbsp;<a href="#sub_OAuth_1_0">OAuth 1.0</a></li><li class="tocline1">7.1.2&nbsp;&nbsp;&nbsp;<a href="#sub_OAuth_2_0">OAuth 2.0</a></li></ul></li><li class="tocline1">7.2&nbsp;&nbsp;&nbsp;<a href="#sub_Adapting_SSHv2_Authentication">Adapting SSHv2 Authentication Mechanisms to RESTauth</a><ul class="toc"><li class="tocline1">7.2.1&nbsp;&nbsp;&nbsp;<a href="#d1e984">RESTauth Mechanism Names for SSHv2 Userauth Methods</a></li><li class="tocline1">7.2.2&nbsp;&nbsp;&nbsp;<a href="#d1e1006">Nonces</a></li><li class="tocline1">7.2.3&nbsp;&nbsp;&nbsp;<a href="#d1e1015">&#8220;Session ID&#8221;</a></li></ul></li><li class="tocline1">7.3&nbsp;&nbsp;&nbsp;<a href="#sub_Adapting_IKEv2_Authentication">Adapting IKEv2 Authentication Mechanisms to RESTauth</a><ul class="toc"><li class="tocline1">7.3.1&nbsp;&nbsp;&nbsp;<a href="#sub_Adaptinve_IKEv2_Password">Adapting IKEv2 Password Authenticated Connection Establishment (PACE) to RESTauth</a></li></ul></li><li class="tocline1">7.4&nbsp;&nbsp;&nbsp;<a href="#sub_Using_SASL_Authentication">Using SASL Authentication Mechanisms with RESTauth</a><ul class="toc"><li class="tocline1">7.4.1&nbsp;&nbsp;&nbsp;<a href="#sub_Using_SCRAM_in">Using SCRAM in RESTauth</a></li><li class="tocline1">7.4.2&nbsp;&nbsp;&nbsp;<a href="#sub_Using_SCRAM_with">Using SCRAM with Round Trip Optimization in RESTauth</a></li></ul></li><li class="tocline1">7.5&nbsp;&nbsp;&nbsp;<a href="#sub_Using_GSS_API_Authentication">Using GSS-API Authentication Mechanisms with RESTauth</a></li></ul></li><li class="tocline0">8.&nbsp;&nbsp;&nbsp;<a href="#sec_IANA_Considerations">IANA Considerations</a></li><li class="tocline0">9.&nbsp;&nbsp;&nbsp;<a href="#sec_Security_Considerations">Security Considerations</a></li><li class="tocline0">10.&nbsp;&nbsp;&nbsp;<a href="#sec_TODO">TODO</a></li><li class="tocline0">11.&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul class="toc"><li class="tocline1">11.1&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li class="tocline1">11.2&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li class="tocline0"><a href="#rfc.authors">Author's Address</a></li><li class="tocline0"><a href="#rfc.ipr">Intellectual Property and Copyright Statements</a></li></ul><ul class="toc"><li class="tocline0"><a href="#rfc.figure.1">Figure 1: WWW-Authenticate ABNF</a></li><li class="tocline0"><a href="#rfc.figure.2">Figure 2: RESTauth w/ SCRAM</a></li><li class="tocline0"><a href="#rfc.figure.3">Figure 3: RESTauth w/ round trip optimized SCRAM</a></li></ul><hr class="noprint"><h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a id="sec_Introduction" href="#sec_Introduction">Introduction</a></h1><p id="rfc.section.1.p.1">We propose a pattern for HTTP <a href="#RFC2616"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a> [XXX add reference to HTTP/2.0 as well] authentication mechanisms that, by being &#8220;RESTful&#8221;, obtains a number of benefits:</p><p id="rfc.section.1.p.2"> </p><ul><li>authentication that works with all versions of HTTP, even when the authentication mechanism requires multiple round trips;</li><li>compatibility with &#8220;HTTP routing&#8221; by making no assumptions that related requests are sent over the same TCP/TLS connection;</li><li>a &#8220;session URI&#8221; results that can be used to multiplex multiple sessions onto the same TCP/TLS connections;</li><li>a &#8220;session URI&#8221; results that can be DELETEd to effect logout;</li><li>a &#8220;session URI&#8221; results that has better security semantics than HTTP cookies;</li><li>the ability to refer to multiple sessions in one request wherever such a concept might be useful;</li><li>can be implemented by any application without changes being required to any HTTP stack;</li><li>can be implemented by the HTTP stack;</li><li>on the server side this can be implemented entirely via CGI and FastCGI;</li><li>by its RESTful nature, multi-legged authentication message exchanges are naturally handled without making any changes to HTTP.</li></ul><p id="rfc.section.1.p.3">There are probably other benefits not listed above.</p><p id="rfc.section.1.p.4">The rough outline of the protocol is quite simple:</p><p id="rfc.section.1.p.5"> </p><ol><li>initial authentication messages are POSTed to an agreed-upon or indicated resource...</li><li>....which then results in a new resource being created with the authentication reply message as the new resource's representation.</li><li>Thereafter any additional authentication message exchanges needed (for multi-legged mechanisms) are POSTed to the new resource creating additional resources.</li><li>The resource created by the POSTing of the initial authentication mechanism identifies the resulting session, and its URI is known as the session URI.</li><li>Session URIs can be used to multiplex multiple sessions over the same TCP/TLS connections, implement logout, and share sessions across multiple related servers.</li></ol><p id="rfc.section.1.p.6">Server-initiated authentication is also possible, whereby the server sends a challenge in 401 errors in headers. If the server gives the client a choice of mechanisms (multiple WWW-Authenticate header values) and the client picks one where the server sent a challenge, then the client consumes that message and POSTs subsequent ones to the indicated URI.</p><hr class="noprint"><h1 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a id="d1e458" href="#d1e458">Conventions used in this document</a></h1><p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p><hr class="noprint"><h1 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a>&nbsp;<a id="d1e473" href="#d1e473">API-Imposed Constraints</a></h1><p id="rfc.section.3.p.1">To the extent that existing Application Programming Interfaces (APIs) assume specific styles of HTTP authentication message flows, if we want those APIs to support RESTauth backwards-compatibly, then those APIs may impose constraints on RESTauth.</p><p id="rfc.section.3.p.2">For example, the Android Account Manager API assumes a single round trip for authentication. But the Android Account Manager could perform all but the last round trip on behalf of the application, then let the application perform the last round trip. In order for that to work we need the authentication message exchange to be orthogonal to TCP/TLS connections &#8211; that is, we need it to be possible to use multiple TCP/TLS connections for completing a single authentication exchange.</p><p id="rfc.section.3.p.3">A typical constraining characteristic might be that an API assumes the use of GET with tokens encoded into the URI, or that the API makes no room for the use of headers in authentication message exchanges.</p><p id="rfc.section.3.p.4">One way to work around such constraints may be to provide various options in this framework. Another might be to use OAuth 1.0 <a href="#RFC5849"><cite title="The OAuth 1.0 Protocol">[RFC5849]</cite></a> or 2.0 <a href="#I-D.ietf-oauth-v2"><cite title="The OAuth 2.0 Authorization Framework">[I-D.ietf-oauth-v2]</cite></a> as a bridge: the API would use this framework under the covers then obtain OAuth credentials from the server that the application can then use in any way that the API's form allows for.</p><p id="rfc.section.3.p.5"> <span class="comment">[rfc.comment.1: 
TODO: Add a table/list of various APIs and their characteristics that might constrain this framework.]</span> </p><hr class="noprint"><h1 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a>&nbsp;<a id="sec_Protocol" href="#sec_Protocol">Protocol</a></h1><p id="rfc.section.4.p.1">The are very few normative protocol elements here besides the outline given in <a href="#sec_Introduction" title="Introduction">Section&nbsp;1</a>. The normative protocol elements are:</p><p id="rfc.section.4.p.2"> </p><ul><li>the form of the WWW-Authenticate header values for RESTauth mechanisms;</li><li>several new headers for advertising negotiable parameters that are orthogonal to WWW-Authenticate;</li><li>the POSTing of authentication messages from the client, with the initial client authentication message going to either a pre-agreed URI or to a URI named in the WWW-Authenticate headers;</li><li>the creation of a session URI as a result of the initial POST, and the subsequent POSTing of any additional authentication messages to the session URI;</li><li>the new session URI resource representation resulting from POSTs being the server's response authentication message, if any;</li><li>the DELETEion of session URIs as signaling logout;</li><li>a new header for referencing session URIs in normal HTTP requests;</li><li>the use of channel binding <a href="#RFC5056"><cite title="On the Use of Channel Bindings to Secure Channels">[RFC5056]</cite></a> to TLS <a href="#RFC5246"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[RFC5246]</cite></a> for session protection;</li><li>the use of session keys as an option for integrity protection when TLS is not used (a light-weight security mode).</li></ul><h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a>&nbsp;<a id="sub_Negotiable_Parameters" href="#sub_Negotiable_Parameters">Negotiable Parameters</a></h2><p id="rfc.section.4.1.p.1">As can be seen in the ABNF in the preceding section, the server can offer some negotiable parameters. These are:</p><p id="rfc.section.4.1.p.2"> </p><ul><li>Mechanism names;</li><li>Channel binding types;</li><li>Session binding types;</li><li>Replay protection;</li></ul><p id="rfc.section.4.1.p.3">Each WWW-Authenticate header value offers a single mechanism and negotiable parameters for it. The WWW-ChannelBinding-Types header allows the server to offer channel binding types.</p><h3 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1</a>&nbsp;<a id="d1e588" href="#d1e588">Strong Binding to TLS</a></h3><p id="rfc.section.4.1.1.p.1">Strong binding to TLS is provided via channel binding <a href="#RFC5056"><cite title="On the Use of Channel Bindings to Secure Channels">[RFC5056]</cite></a>. When a RESTauth mechanism provides strong authentication of the service to the user, the combination of RESTauth and channel binding results in strong authentication of the server to the user even though TLS is used for session transport protection.</p><h3 id="rfc.section.4.1.2"><a href="#rfc.section.4.1.2">4.1.2</a>&nbsp;<a id="sub_WWW_Authenticate_Header_Value" href="#sub_WWW_Authenticate_Header_Value">WWW-Authenticate Header Value Prefix Syntax</a></h3><p id="rfc.section.4.1.2.p.1">The ABNF for RESTauth WWW-Authenticate header values is as follows:</p><p id="rfc.section.4.1.2.p.3"> </p><div id="fig_WWW_Authenticate_ABNF"></div><div id="rfc.figure.1"></div><pre>      challenge           = ( "RA-" mechname SP restauth-challenge )
      mechname            = TBD
      restauth-challenge  = ( login-uri SP session-types SP
                              replay-prot SP *1(mech-challenge) )
      login-uri           = absoluteURI
      session-types       = "s=" session-type /
                            (session-type ":" session-types)
      session-type        = "cookie" / "session-ID" / "MAC"
      replay-prot         = "r=" ("yes" / "no")
      ; TODO: add production for
      ;       mech-challenge as a base64 string
      ; TODO: add MAC algorithm offers for alg agility?</pre><p class="figure">Figure 1: WWW-Authenticate ABNF</p><p id="rfc.section.4.1.2.p.4">For a DIGEST-like mechanism it might look like &#8220;WWW-Authenticate: RA-Digest-SHA-256 tls-server-end-point session-ID no HE4SgWGrd/3+O7t16HqusA==&#8221;. For example, the mechname for the Kerberos V5 GSS-API mechanism might be &#8220;gss-krb5&#8221;, and a WWW-Authenticate header value for it might look like &#8220;WWW-Authenticate: RA-gss-krb5 http://foo.example/restauth-login tls-server-end-point session-ID no&#8221;.</p><p id="rfc.section.4.1.2.p.5">Note that mechanisms that may be used include: GSS mechanisms, SASL mechanisms, ad-hoc mechanisms, and so on.</p><h3 id="rfc.section.4.1.3"><a href="#rfc.section.4.1.3">4.1.3</a>&nbsp;<a id="sub_WWW_ChannelBinding_Types_Header" href="#sub_WWW_ChannelBinding_Types_Header">WWW-ChannelBinding-Types Header</a></h3><p id="rfc.section.4.1.3.p.1">A new header is added by which servers MUST indicate which channel binding <a href="#RFC5056"><cite title="On the Use of Channel Bindings to Secure Channels">[RFC5056]</cite></a> types -if any- they support for RESTauth authentication; if the server does not support channel binding then this header MUST be absent. The header is named WWW-ChannelBinding-Types. Its values are channel binding types from the channel binding type registry <a href="#RFC5929"><cite title="Channel Bindings for TLS">[RFC5929]</cite></a>.</p><h3 id="rfc.section.4.1.4"><a href="#rfc.section.4.1.4">4.1.4</a>&nbsp;<a id="sub_WWW_ChannelBinding_Type_Header" href="#sub_WWW_ChannelBinding_Type_Header">WWW-ChannelBinding-Type Header</a></h3><p id="rfc.section.4.1.4.p.1">A new header is added by which clients MUST indicate what channel binding type they used when POSTing RESTauth authentication messages, if any; if the client did not use channel binding then this header MUST be absent. If the mechanism used has its own method for indicating the use of channel binding, then this header MAY be ommitted. The header is named WWW-ChannelBinding-Type. Its value is a channel binding type from the channel binding type registry <a href="#RFC5929"><cite title="Channel Bindings for TLS">[RFC5929]</cite></a>.</p><h3 id="rfc.section.4.1.5"><a href="#rfc.section.4.1.5">4.1.5</a>&nbsp;<a id="sub_WWW_SessionType_Header" href="#sub_WWW_SessionType_Header">WWW-SessionBinding-Type Header</a></h3><p id="rfc.section.4.1.5.p.1">A new header is added by which clients MUST indicate what session binding type they choose when POSTing RESTauth authentication messages. The header is named WWW-SessionBinding-Type. Its value is a session binding type as shown in <a href="#fig_WWW_Authenticate_ABNF">Figure&nbsp;1</a>. This header SHOULD be present in RESTauth authentication HTTP requests, but may be ommitted when the selected mechanism provides its own session binding facility that is distinct from RESTauth's (this helps adapt OAuth to RESTauth with minimal or no changes).</p><h3 id="rfc.section.4.1.6"><a href="#rfc.section.4.1.6">4.1.6</a>&nbsp;<a id="sub_WWW_ReplayProtection_Header" href="#sub_WWW_ReplayProtection_Header">WWW-ReplayProtection Header</a></h3><p id="rfc.section.4.1.6.p.1">A new header is added by which clients MUST indicate whether they desire replay protection when POSTing RESTauth authentication messages. The header is named WWW-SessionBinding-Type. Its value is &#8220;yes&#8221; or &#8220;no&#8221; (defaults to &#8220;no&#8221; if absent) as shown in <a href="#fig_WWW_Authenticate_ABNF">Figure&nbsp;1</a>.</p><p id="rfc.section.4.1.6.p.2">Replay protection is to be used only when TLS <a href="#RFC5246"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[RFC5246]</cite></a> is not, and only if a session binding type of &#8220;MAC&#8221; is also requested.</p><h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a>&nbsp;<a id="sub_Protocol_Flow" href="#sub_Protocol_Flow">Protocol Flow</a></h2><p id="rfc.section.4.2.p.1">RESTauth can be initiated by a client that knows a priori that it needs to or wants to use RESTauth. Servers can also tell clients that access to certain resources require authentication, possibly including RESTauth mechanisms. When the server tells the client that it must authenticate, the server may also give the client an initial authentication message for one or more mechanisms.</p><p id="rfc.section.4.2.p.2">When the client knows a priori that it must authenticate then the client MUST know the RESTauth login URI a priori as well, as well as negotiable parameters, all of which the client might know from either an application protocol specification, or from caching this information from earlier RESTauth exchanges.</p><p id="rfc.section.4.2.p.3">The server MUST use a 401 HTTP status code and WWW-Authenticate headers to inform the client of the need to authenticate in order to access a given resource. For RESTauth mechanisms the WWW-Authenticate header values MUST conform to the ABNF given in <a href="#sub_WWW_Authenticate_Header_Value" title="WWW-Authenticate Header Value Prefix Syntax">Section&nbsp;4.1.2</a>.</p><p id="rfc.section.4.2.p.4">To proceed the client chooses a suitable authentication mechanism (for which, presumably, it has credentials for a desired client identity), possibly a channel binding type, possibly a session type, and whether to use replay protection.</p><h3 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1</a>&nbsp;<a id="sub_One_Round_Trip" href="#sub_One_Round_Trip">One Round Trip Optimization: Challenges Born in WWW-Authenticate Headers</a></h3><p id="rfc.section.4.2.1.p.1">Some mechanisms may optimize the protocol flow by allowing the server to include challenges in the 401 response's WWW-Authenticate header values. DIGEST-MD5 works this way, for example, sending a challenge nonce to be fed into the digest function (along with other client-side inputs).</p><p id="rfc.section.4.2.1.p.2">RESTauth allows this, but this feature is OPTIONAL: it must always be possible for a client to initiate RESTauth without first obtaining a challenge in a WWW-Authenticate header value, in which case the client must incur an extra protocol leg by obtaining the challenge (if it is at all necessary) in the server's reply to the client's first authentication message. There are two reasons for making this optional:</p><p id="rfc.section.4.2.1.p.3"> </p><ol><li>to allow client applications that know a priori that they must authenticate, requiring no further negotiation;</li><li>to support authentication frameworks that require that the client initiate authentication message exchanges.</li></ol><p id="rfc.section.4.2.1.p.4">A challenge may consist of a nonce, some encrypted or MACed nonce, a time-stamp, certificates and digital signatures, etcetera. The server may include a login URI in challenge-laden WWW-Authenticate headers where the login URI encodes secure state regarding the challenge (e.g., the challenge encrypted in a symmetric key known only to the server).</p><h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3</a>&nbsp;<a id="sub_Session_Binding_Types_" href="#sub_Session_Binding_Types_">Session Binding Types: Cookie, URI, and MAC</a></h2><p id="rfc.section.4.3.p.1">A notion of session binding type is added for binding HTTP requests to specific RESTauth login sessions. Three types are provided:</p><p id="rfc.section.4.3.p.2"> </p><dl><dt>Cookies</dt><dd>The traditional HTTP cookie approach to session binding;</dd><dt>Session&nbsp;URI</dt><dd>HTTP requests carry a WWW-Session-URI header identifying the session(s) (similar to cookies, but without all the associated baggage);</dd><dt>MAC</dt><dd>HTTP requests carry a WWW-Session-URI header identifying the session(s) and a WWW-Session-MAC header that carries a MAC or MACs binding the session URI(s) to the request.</dd></dl><h3 id="rfc.section.4.3.1"><a href="#rfc.section.4.3.1">4.3.1</a>&nbsp;<a id="sub_The_New_WWW_Session_URI" href="#sub_The_New_WWW_Session_URI">The New WWW-Session-URI Header</a></h3><p id="rfc.section.4.3.1.p.1">A new HTTP header is added called WWW-Session-URI whose values consist of session URIs. At least one session URI MUST be included. Each session URI is an absoluteURI. Session URIs MUST NOT have unescaped commas (',') embedded in them. Servers MAY fail to implement support for multiple session URIs being referenced by a single request, in which case they MUST answer with error code &lt;TBD&gt;. Servers MUST validate the session URI before processing the request; if the session URI is invalid the server MUST respond with a 401 (or TBD?) status code.</p><p id="rfc.section.4.3.1.p.2">Note that referencing multiple session URIs is permitted, but this may not be meaningful for the application, thus the server MAY reject this (TODO: specify a status code for this?).</p><p id="rfc.section.4.3.1.p.3"> <span class="comment">[rfc.comment.2: 
I can imagine a webmail application where a client can be logged in as multiple users and get a unified view of the users' mailboxes. This seems unlikely, but why rule out such use cases?]</span> </p><h3 id="rfc.section.4.3.2"><a href="#rfc.section.4.3.2">4.3.2</a>&nbsp;<a id="sub_The_New_WWW_Session_MAC" href="#sub_The_New_WWW_Session_MAC">The New WWW-Session-MAC Header</a></h3><p id="rfc.section.4.3.2.p.1"> <span class="comment">[rfc.comment.3: 
Describe the header, its values, algorithm agility, and what the MAC is to be taken over. Note too that this cannot apply to request contents as we have to consider chunking, and besides, a MAC of contents really has to go as a trailer, not a header.]</span> </p><h3 id="rfc.section.4.3.3"><a href="#rfc.section.4.3.3">4.3.3</a>&nbsp;<a id="sub_A_MAC_Trailer__" href="#sub_A_MAC_Trailer__">A MAC Trailer??</a></h3><p id="rfc.section.4.3.3.p.1"> <span class="comment">[rfc.comment.4: 
... This is only needed for RESTauth *without* TLS, which will probably not be the common mode of use for RESTauth... unless we can produce a MAC trailer extension for HTTP/2.0, in which case this may well become a common mode of RESTauth usage.]</span> </p><hr class="noprint"><h1 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a>&nbsp;<a id="sec_HTTP_Routing_and" href="#sec_HTTP_Routing_and">HTTP &#8220;Routing&#8221; and Authentication</a></h1><p id="rfc.section.5.p.1">It is common to deploy HTTP services with load-balanced servers behind a load balancer and TLS concentrator. Other techniques may also result in a multiplicity of servers acting on behalf of a single service. The load balancers may even behave like routers and route HTTP requests to the same server for all requests in a single connection, or even route HTTP requests according to the verb and resource. It helps to be able to have a notion of authenticated sessions that can be referenced by all servers responding to a given service name.</p><p id="rfc.section.5.p.2">The server end of a RESTauth authentication message exchange may be terminated by one server, by many servers sharing session state (via the resources named by session URIs), or by a server-side HTTP router. Once a RESTauth session is established we assume that all servers responding to the same service name will be able to access the session resource, validate session URIs, and obtain keys for computing and validating session binding MACs. Alternatively, the router may take responsibility for session binding and signal authorization information from the established session to the HTTP servers behind the router (however, we do not here specify any methods for such signaling).</p><p id="rfc.section.5.p.3">By using REST for the authentication message exchange we allow this disconnection between &#8220;session&#8221; and &#8220;connection&#8221;, which therefore facilitates &#8220;routing&#8221; of HTTP requests and even off-loading of authentication and/or session binding to HTTP &#8220;routers&#8221;.</p><p id="rfc.section.5.p.4">This approach should be flexible enough for all existing architectures for deploying HTTP services.</p><hr class="noprint"><h1 id="rfc.section.6" class="np"><a href="#rfc.section.6">6.</a>&nbsp;<a id="d1e858" href="#d1e858">In-band HTTP Authentication Alternatives</a></h1><p id="rfc.section.6.p.1">RESTauth is &#8220;out-of-band&#8221; in the sense that the authentication messages are exchanged independently of the application's requests for normal resources. Of course, RESTauth exchanges may well (and often will) happen in the same TCP/TLS connection as normal application requests, so RESTauth is not really out-of-band. We use &#8220;out-of-band&#8221; and &#8220;in-band&#8221; very loosely in this section.</p><p id="rfc.section.6.p.2">There exist several &#8220;in-band&#8221; HTTP authentication alternatives where the authentication message exchanges happen in the context of application resources. Here the HTTP verb and resource are application-specific and have nothing to do with authentication, and the authentication messages are exchanged via HTTP request and response headers with the server responding with a 401 status code until authentication is complete.</p><p id="rfc.section.6.p.3">The extant &#8220;Basic&#8221; and &#8220;DIGEST-MD5&#8221; <a href="#RFC2617"><cite title="HTTP Authentication: Basic and Digest Access Authentication">[RFC2617]</cite></a> HTTP authentication methods, as well as HTTP/Negotiate <a href="#RFC4559"><cite title="SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows">[RFC4559]</cite></a> are &#8220;in-band&#8221; HTTP authentication methods.</p><p id="rfc.section.6.p.4">In so far as an in-band authentication method results in a cookie or session URI/ID the distinction between in-band and out-of-band is almost trivial, as described above: authentication messages in headers vs. bodies, and HTTP verb and URL. However, if in-line authentication methods are strongly tied to the TCP/TLS connections over which they were utilized then that is a big disadvantage over RESTauth: each connection requires re-authenticating, and support for HTTP routing schemes is not clear.</p><p id="rfc.section.6.p.5">HTTP/Negotiate is more troublesome because historically it has required re-authentication per-HTTP request(!).</p><p id="rfc.section.6.p.6">Even if the only difference between in-band and out-of-band is a trivial one, using the REST pattern means that authentication can be implemented using with no help from the HTTP stack (even though it's desirable to have it implemented within/by the HTTP stack), whereas there may not be a way to implement in-band authentication without help from the HTTP stack for some stacks.</p><hr class="noprint"><h1 id="rfc.section.7" class="np"><a href="#rfc.section.7">7.</a>&nbsp;<a id="sec_Sample_Potential_RESTauth_Authen" href="#sec_Sample_Potential_RESTauth_Authen">Sample/Potential RESTauth Authentication Mechanisms</a></h1><p id="rfc.section.7.p.1">Here we describe (informatively, for the time being) how to use or adapt a variety of authentication mechanisms, from SSHv2, IKEv2, SASL, GSS-API, and other frameworks, so as to quickly gain a set of usable mechanisms, both, specification- and implementation-wise. This section is also intended to show that adding RESTauth mechanisms is easy.</p><h2 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1</a>&nbsp;<a id="sub_OAuth_via_RESTauth" href="#sub_OAuth_via_RESTauth">OAuth via RESTauth</a></h2><p id="rfc.section.7.1.p.1">OAuth 1.0 RFC5849 and OAuth 2.0 <a href="#I-D.ietf-oauth-v2"><cite title="The OAuth 2.0 Authorization Framework">[I-D.ietf-oauth-v2]</cite></a> are commonly deployed. Being able to use OAuth via RESTauth would be useful. We attempt to make RESTauth such that at least for OAuth 1.0 there is a standard way to use OAuth such that it conforms to RESTauth.</p><h3 id="rfc.section.7.1.1"><a href="#rfc.section.7.1.1">7.1.1</a>&nbsp;<a id="sub_OAuth_1_0" href="#sub_OAuth_1_0">OAuth 1.0</a></h3><p id="rfc.section.7.1.1.p.1">For OAuth 1.0 <a href="#RFC5849"><cite title="The OAuth 1.0 Protocol">[RFC5849]</cite></a> the &#8220;form-encoded body&#8221; form (see section 3.5.2 of <a href="#RFC5849"><cite title="The OAuth 1.0 Protocol">[RFC5849]</cite></a>) of OAuth 1.0 conforms to RESTauth without further changes.</p><h3 id="rfc.section.7.1.2"><a href="#rfc.section.7.1.2">7.1.2</a>&nbsp;<a id="sub_OAuth_2_0" href="#sub_OAuth_2_0">OAuth 2.0</a></h3><p id="rfc.section.7.1.2.p.1">[It looks like OAuth 2.0 <a href="#I-D.ietf-oauth-v2"><cite title="The OAuth 2.0 Authorization Framework">[I-D.ietf-oauth-v2]</cite></a> also uses POST to send tokens to the server, and it looks like it too effectively conforms to RESTauth.]</p><h2 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2</a>&nbsp;<a id="sub_Adapting_SSHv2_Authentication" href="#sub_Adapting_SSHv2_Authentication">Adapting SSHv2 Authentication Mechanisms to RESTauth</a></h2><p id="rfc.section.7.2.p.1">SSHv2 &#8220;userauth&#8221; mechanisms <a href="#RFC4252"><cite title="The Secure Shell (SSH) Authentication Protocol">[RFC4252]</cite></a> typically involve a digital signature (or similar) of an SSHv2 session ID. There is no such thing as an SSHv2 session ID in HTTP. A session URI cannot serve as a stand-in for an SSHv2 session ID because a) the session URI is an outcome of authentication in RESTauth, b) to prevent cut-n-paste and replay attacks the client and the server both must contribute to the entropy of the session ID that is signed by the client.</p><p id="rfc.section.7.2.p.2">In order to adapt SSHv2 userauth methods properly (i.e., securely), we have replace the SSHv2 session ID in the to-be-signed data with a hash of the channel binding and nonces contributed by the client and the server. As an optimization the server nonce can be sent as a challenge (this saves a round trip).</p><h3 id="rfc.section.7.2.1"><a href="#rfc.section.7.2.1">7.2.1</a>&nbsp;<a id="d1e984" href="#d1e984">RESTauth Mechanism Names for SSHv2 Userauth Methods</a></h3><p id="rfc.section.7.2.1.p.1">For hash agility reasons the hash function name is part of the SSHv2 RESTauth mechanism name. To avoid &#8220;multi-level negotiation&#8221; the SSHv2 userauth method name is also part of the RESTauth mechanism name.</p><p id="rfc.section.7.2.1.p.2">The RESTauth mechanism name form for SSHv2 userauth methods, then, is: ssh-&lt;SSHv2-userauth-method-name&gt;-&lt;hash-function-name&gt;.</p><p id="rfc.section.7.2.1.p.3">The following RESTauth mechanisms are defined here:</p><p id="rfc.section.7.2.1.p.4"> </p><ul><li>ssh-publickey-SHA-256</li><li>ssh-hostbased-SHA-256</li></ul><h3 id="rfc.section.7.2.2"><a href="#rfc.section.7.2.2">7.2.2</a>&nbsp;<a id="d1e1006" href="#d1e1006">Nonces</a></h3><p id="rfc.section.7.2.2.p.1">The client and the server must each contribute 128-bit nonces.</p><h3 id="rfc.section.7.2.3"><a href="#rfc.section.7.2.3">7.2.3</a>&nbsp;<a id="d1e1015" href="#d1e1015">&#8220;Session ID&#8221;</a></h3><p id="rfc.section.7.2.3.p.1">The ssh-publickey-SHA-256 and ssh-hostbased-SHA-256 mechanisms use the following instead of a traditional SSHv2 session ID:</p><p id="rfc.section.7.2.3.p.2"> </p><ul><li>SHA-256(channel_binding || server_nonce || client_nonce)</li></ul><p id="rfc.section.7.2.3.p.3">Here the &lt;channel_binding&gt; is as per-<a href="#RFC5056"><cite title="On the Use of Channel Bindings to Secure Channels">[RFC5056]</cite></a>: the channel binding type name, followed by the channel binding data (e.g., 'tls-server-end-point' followed by the server EE certificate as sent in the server's TLS Certificate message).</p><p id="rfc.section.7.2.3.p.4">Note that use of channel binding when using SSHv2 mechanisms is REQUIRED so as to defeat cut-n-paste attacks by weakly-authenticated servers.</p><h2 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3</a>&nbsp;<a id="sub_Adapting_IKEv2_Authentication" href="#sub_Adapting_IKEv2_Authentication">Adapting IKEv2 Authentication Mechanisms to RESTauth</a></h2><p id="rfc.section.7.3.p.1"> <span class="comment">[rfc.comment.5: 
TBD.]</span> </p><h3 id="rfc.section.7.3.1"><a href="#rfc.section.7.3.1">7.3.1</a>&nbsp;<a id="sub_Adaptinve_IKEv2_Password" href="#sub_Adaptinve_IKEv2_Password">Adapting IKEv2 Password Authenticated Connection Establishment (PACE) to RESTauth</a></h3><p id="rfc.section.7.3.1.p.1"> <span class="comment">[rfc.comment.6: 
TBD.]</span> </p><h2 id="rfc.section.7.4"><a href="#rfc.section.7.4">7.4</a>&nbsp;<a id="sub_Using_SASL_Authentication" href="#sub_Using_SASL_Authentication">Using SASL Authentication Mechanisms with RESTauth</a></h2><p id="rfc.section.7.4.p.1">Simple Authentication and Security Layers (SASL) <a href="#RFC4422"><cite title="Simple Authentication and Security Layer (SASL)">[RFC4422]</cite></a> is a simple, pluggable framework for authentication mechanisms.</p><p id="rfc.section.7.4.p.2">To use a SASL mechanism in RESTauth just prefix &#8220;SA-&#8221; to the SASL mechanism name and use that as the RESTauth mechanism name. If the SASL mechanism is server-initiated then the server's challenge is sent in the server's WWW-Authenticate header value as described above. All other SASL authentication messages are exchanged as described above (i.e., via POSTs, first to the login URI, then to the session URI, with response messages as the new representation of the session resource).</p><p id="rfc.section.7.4.p.3">The HTTP status code functions as the application's outcome of authentication message. If SASL succeeds but authorization fails then the server should respond with a 401 status code to the POST of the final SASL authentication message from the client.</p><p id="rfc.section.7.4.p.4">The server's WWW-Authenticate header values function as the mechanism listing operation. SASL security considerations <a href="#RFC4422"><cite title="Simple Authentication and Security Layer (SASL)">[RFC4422]</cite></a>  <a href="#RFC5801"><cite title="Using Generic Security Service Application Program Interface (GSS-API) Mechanisms in Simple Authentication and Security Layer (SASL): The GS2 Mechanism Family">[RFC5801]</cite></a> apply (particularly regarding the negotiation of channel binding support).</p><h3 id="rfc.section.7.4.1"><a href="#rfc.section.7.4.1">7.4.1</a>&nbsp;<a id="sub_Using_SCRAM_in" href="#sub_Using_SCRAM_in">Using SCRAM in RESTauth</a></h3><p id="rfc.section.7.4.1.p.1">The Salted Challenge Response Authentication Mechanism (SCRAM) <a href="#RFC5802"><cite title="Salted Challenge Response Authentication Mechanism (SCRAM) SASL and GSS-API Mechanisms">[RFC5802]</cite></a> is a DIGEST-like mechanism for SASL. Nothing special is needed to use SCRAM versus any other SASL mechanism, except for a round trip optimized form of SCRAM, if we decide to pursue that (see <a href="#sub_Using_SCRAM_with" title="Using SCRAM with Round Trip Optimization in RESTauth">Section&nbsp;7.4.2</a>).</p><p id="rfc.section.7.4.1.p.2">The following figure shows what SCRAM in RESTauth looks like. Note that the resource representations are taken verbatim from <a href="#RFC5802"><cite title="Salted Challenge Response Authentication Mechanism (SCRAM) SASL and GSS-API Mechanisms">[RFC5802]</cite></a>.</p><p id="rfc.section.7.4.1.p.4"> </p><div id="magicparlabel-362"></div><div id="rfc.figure.2"></div><pre>  C-&gt;S: GET /some-resources HTTP/1.1
        Host: A.example
 
  S-&gt;C: HTTP/1.1 401 Unauthorized
        WWW-Authenticate: RA-SA-SCRAM-SHA-1 \
                          http://A.example/rest-sa-scram \ 
                          s=session-ID,MIC r=no
        WWW-ChannelBinding-Types: tls-server-end-point
 
  C-&gt;S: POST /rest-sa-scram HTTP/1.1
        Host: A.example
        WWW-ChannelBinding-Type: tls-server-end-point
        WWW-SessionBinding-Type: session-ID
        Content-Type: application/octet-stream
        Content-Length: nnn
 
        n,,n=user,r=fyko+d2lbbFgONRv9qkxdawL
 
  S-&gt;C: HTTP/1.1 201
        Location http://A.example/restauth-9d0af5f680d4ff46
        Content-Type: application/octet-stream
        Content-Length: nnn
 
        r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,
        s=QSXCR+Q6sek8bf92,i=4096
 
  C-&gt;S: POST /restauth-9d0af5f680d4ff46 HTTP/1.1
        Host: A.example
        Content-Type: application/octet-stream
        Content-Length: nnn
 
        c=biws,r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,
        p=v0X8v3Bz2T0CJGbJQyF0X+HI4Ts=
 
  S-&gt;C: HTTP/1.1 200
        Content-Type: application/octet-stream
        Content-Length: nnn
 
        v=rmF9pqV8S7suAoZWja4dJRkFsKQ=
 </pre><p class="figure">Figure 2: RESTauth w/ SCRAM</p><h3 id="rfc.section.7.4.2"><a href="#rfc.section.7.4.2">7.4.2</a>&nbsp;<a id="sub_Using_SCRAM_with" href="#sub_Using_SCRAM_with">Using SCRAM with Round Trip Optimization in RESTauth</a></h3><p id="rfc.section.7.4.2.p.1"> <span class="comment">[rfc.comment.7: 
This might work by having the authentication ID function as the salt and the server offering a challenge nonce and iteration count in its optimistic challenge. However, it's not clear that a round trip optimized form of SCRAM is desirable.]</span> </p><p id="rfc.section.7.4.2.p.2">The following figure shows what a round trip optimized RESTauth w/ SCRAM exchange might look like.</p><p id="rfc.section.7.4.2.p.3"> <span class="comment">[rfc.comment.8: 
NOTE: SCRAM was not intended to be used this way. In particular this approach forces the use of an algorithmic salt, to be derived only from either the username or the username and the server's name (or else to be remembered by the user, but that's not likely).]</span> </p><p id="rfc.section.7.4.2.p.5"> </p><div id="magicparlabel-407"></div><div id="rfc.figure.3"></div><pre>  C-&gt;S: GET /some-resources HTTP/1.1
        Host: A.example
 
  S-&gt;C: HTTP/1.1 401 Unauthorized
        WWW-Authenticate: RA-SA-SCRAM-SHA-1 \
                          http://A.example/rest-sa-scram \
                          s=session-ID,MIC r=no \
                          r=fyko+d2l...JY1ZVvWVs7j,i=4096
        WWW-ChannelBinding-Types: tls-server-end-point
 
  C-&gt;S: POST /rest-sa-scram HTTP/1.1
        Host: A.example
        WWW-ChannelBinding-Type: tls-server-end-point
        WWW-SessionBinding-Type: session-ID
        Content-Type: application/octet-stream
        Content-Length: nnn
 
        n,,n=user,r=fyko+d2lbbFgONRv9qkxdawL,
        c=biws,r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,
        p=v0X8v3Bz2T0CJGbJQyF0X+HI4Ts=
 
  S-&gt;C: HTTP/1.1 200
        Content-Type: application/octet-stream
        Content-Length: nnn
 
        v=rmF9pqV8S7suAoZWja4dJRkFsKQ=
 </pre><p class="figure">Figure 3: RESTauth w/ round trip optimized SCRAM</p><h2 id="rfc.section.7.5"><a href="#rfc.section.7.5">7.5</a>&nbsp;<a id="sub_Using_GSS_API_Authentication" href="#sub_Using_GSS_API_Authentication">Using GSS-API Authentication Mechanisms with RESTauth</a></h2><p id="rfc.section.7.5.p.1">The Generic Security Services Application Programming Interface (GSS-API) <a href="#RFC2743"><cite title="Generic Security Service Application Program Interface Version 2, Update 1">[RFC2743]</cite></a> is another pluggable mechanism framework. Any GSS-API mechanism that supports channel binding <a href="#RFC5056"><cite title="On the Use of Channel Bindings to Secure Channels">[RFC5056]</cite></a> can be used as SASL mechanisms via the &#8220;SASL/GS2&#8221; bridge <a href="#RFC5801"><cite title="Using Generic Security Service Application Program Interface (GSS-API) Mechanisms in Simple Authentication and Security Layer (SASL): The GS2 Mechanism Family">[RFC5801]</cite></a>. This includes the Kerberos V5 GSS-API mechanism <a href="#RFC4121"><cite title="The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2">[RFC4121]</cite></a>.</p><hr class="noprint"><h1 id="rfc.section.8" class="np"><a href="#rfc.section.8">8.</a>&nbsp;<a id="sec_IANA_Considerations" href="#sec_IANA_Considerations">IANA Considerations</a></h1><p id="rfc.section.8.p.1">TBD (header registrations, ...)</p><hr class="noprint"><h1 id="rfc.section.9" class="np"><a href="#rfc.section.9">9.</a>&nbsp;<a id="sec_Security_Considerations" href="#sec_Security_Considerations">Security Considerations</a></h1><p id="rfc.section.9.p.1">This entire document deals with security considerations. [Add more, like about channel binding, same-origin-like constraints on the login and session absolute URIs', ...]</p><hr class="noprint"><h1 id="rfc.section.10" class="np"><a href="#rfc.section.10">10.</a>&nbsp;<a id="sec_TODO" href="#sec_TODO">TODO</a></h1><p id="rfc.section.10.p.1"> <span class="comment">[rfc.comment.9: 
Add references (to HTTP/2.0, CGI/fCGI, ...).]</span> </p><p id="rfc.section.10.p.2"> <span class="comment">[rfc.comment.10: 
Describe MAC session binding option and replay protection in detail. Describe how to extract keys for MAC keying from SASL/GSS/PACE.]</span> </p><p id="rfc.section.10.p.3"> <span class="comment">[rfc.comment.11: 
Figure out how to adapt IKEv2 password-based methods to RESTauth. This may not be worthwhile (since each method tends to depend heavily on the entire IKEv2 framework in ways that add messaging that we'd not need in RESTauth).]</span> </p><hr class="noprint"><h1 id="rfc.references" class="np"><a id="rfc.section.11" href="#rfc.section.11">11.</a> References</h1><h2 class="np" id="rfc.references.1"><a href="#rfc.section.11.1" id="rfc.section.11.1">11.1</a> Normative References</h2><table summary="Normative References"><tr><td class="reference"><b id="RFC2119">[RFC2119]</b></td><td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>&#8221;, BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.</td></tr><tr><td class="reference"><b id="RFC2616">[RFC2616]</b></td><td class="top"><a href="mailto:fielding@ics.uci.edu" title="Department of Information and Computer Science">Fielding, R.</a>, <a href="mailto:jg@w3.org" title="World Wide Web Consortium">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com" title="Compaq Computer Corporation">Mogul, J.</a>, <a href="mailto:frystyk@w3.org" title="World Wide Web Consortium">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com" title="Xerox Corporation">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.</a>, and <a href="mailto:timbl@w3.org" title="World Wide Web Consortium">T. Berners-Lee</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>&#8221;, RFC&nbsp;2616, June&nbsp;1999.</td></tr><tr><td class="reference"><b id="RFC2617">[RFC2617]</b></td><td class="top"><a href="mailto:john@math.nwu.edu" title="Northwestern University, Department of Mathematics">Franks, J.</a>, <a href="mailto:pbaker@verisign.com" title="Verisign Inc.">Hallam-Baker, P.M.</a>, <a href="mailto:jeff@AbiSource.com" title="AbiSource, Inc.">Hostetler, J.L.</a>, <a href="mailto:lawrence@agranat.com" title="Agranat Systems, Inc.">Lawrence, S.D.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.J.</a>, Luotonen, A., and <a href="mailto:stewart@OpenMarket.com" title="Open Market, Inc.">L. Stewart</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2617">HTTP Authentication: Basic and Digest Access Authentication</a>&#8221;, RFC&nbsp;2617, June&nbsp;1999.</td></tr><tr><td class="reference"><b id="RFC5246">[RFC5246]</b></td><td class="top">Dierks, T. and E. Rescorla, &#8220;<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>&#8221;, RFC&nbsp;5246, August&nbsp;2008.</td></tr><tr><td class="reference"><b id="RFC5056">[RFC5056]</b></td><td class="top">Williams, N., &#8220;<a href="http://tools.ietf.org/html/rfc5056">On the Use of Channel Bindings to Secure Channels</a>&#8221;, RFC&nbsp;5056, November&nbsp;2007.</td></tr><tr><td class="reference"><b id="RFC5929">[RFC5929]</b></td><td class="top">Altman, J., Williams, N., and L. Zhu, &#8220;<a href="http://tools.ietf.org/html/rfc5929">Channel Bindings for TLS</a>&#8221;, RFC&nbsp;5929, July&nbsp;2010.</td></tr></table><h2 id="rfc.references.2"><a href="#rfc.section.11.2" id="rfc.section.11.2">11.2</a> Informative References</h2><table summary="Informative References"><tr><td class="reference"><b id="RFC5849">[RFC5849]</b></td><td class="top">Hammer-Lahav, E., &#8220;<a href="http://tools.ietf.org/html/rfc5849">The OAuth 1.0 Protocol</a>&#8221;, RFC&nbsp;5849, April&nbsp;2010.</td></tr><tr><td class="reference"><b id="I-D.ietf-oauth-v2">[I-D.ietf-oauth-v2]</b></td><td class="top">Hardt, D., &#8220;<a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-31">The OAuth 2.0 Authorization Framework</a>&#8221;, Internet-Draft&nbsp;draft-ietf-oauth-v2-31 (work in progress), August&nbsp;2012.</td></tr><tr><td class="reference"><b id="RFC4422">[RFC4422]</b></td><td class="top">Melnikov, A. and K. Zeilenga, &#8220;<a href="http://tools.ietf.org/html/rfc4422">Simple Authentication and Security Layer (SASL)</a>&#8221;, RFC&nbsp;4422, June&nbsp;2006.</td></tr><tr><td class="reference"><b id="RFC5802">[RFC5802]</b></td><td class="top">Newman, C., Menon-Sen, A., Melnikov, A., and N. Williams, &#8220;<a href="http://tools.ietf.org/html/rfc5802">Salted Challenge Response Authentication Mechanism (SCRAM) SASL and GSS-API Mechanisms</a>&#8221;, RFC&nbsp;5802, July&nbsp;2010.</td></tr><tr><td class="reference"><b id="RFC4252">[RFC4252]</b></td><td class="top">Ylonen, T. and C. Lonvick, &#8220;<a href="http://tools.ietf.org/html/rfc4252">The Secure Shell (SSH) Authentication Protocol</a>&#8221;, RFC&nbsp;4252, January&nbsp;2006.</td></tr><tr><td class="reference"><b id="RFC4559">[RFC4559]</b></td><td class="top">Jaganathan, K., Zhu, L., and J. Brezak, &#8220;<a href="http://tools.ietf.org/html/rfc4559">SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows</a>&#8221;, RFC&nbsp;4559, June&nbsp;2006.</td></tr><tr><td class="reference"><b id="RFC6631">[RFC6631]</b></td><td class="top">Kuegler, D. and Y. Sheffer, &#8220;<a href="http://tools.ietf.org/html/rfc6631">Password Authenticated Connection Establishment with the Internet Key Exchange Protocol version 2 (IKEv2)</a>&#8221;, RFC&nbsp;6631, June&nbsp;2012.</td></tr><tr><td class="reference"><b id="RFC2743">[RFC2743]</b></td><td class="top"><a href="mailto:jlinn@rsasecurity.com" title="RSA Laboratories">Linn, J.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>&#8221;, RFC&nbsp;2743, January&nbsp;2000.</td></tr><tr><td class="reference"><b id="RFC5801">[RFC5801]</b></td><td class="top">Josefsson, S. and N. Williams, &#8220;<a href="http://tools.ietf.org/html/rfc5801">Using Generic Security Service Application Program Interface (GSS-API) Mechanisms in Simple Authentication and Security Layer (SASL): The GS2 Mechanism Family</a>&#8221;, RFC&nbsp;5801, July&nbsp;2010.</td></tr><tr><td class="reference"><b id="RFC4121">[RFC4121]</b></td><td class="top">Zhu, L., Jaganathan, K., and S. Hartman, &#8220;<a href="http://tools.ietf.org/html/rfc4121">The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2</a>&#8221;, RFC&nbsp;4121, July&nbsp;2005.</td></tr></table><hr class="noprint"><h1 id="rfc.authors" class="np"><a href="#rfc.authors">Author's Address</a></h1><address class="vcard"><span class="vcardline"><span class="fn">Nicolas Williams</span><span class="n hidden"><span class="family-name">Williams</span><span class="given-name">Nicolas</span></span></span><span class="org vcardline">Cryptonector, LLC</span><span class="vcardline">EMail: <a href="mailto:nico@cryptonector.com"><span class="email">nico@cryptonector.com</span></a></span></address><p class="error">

  This stylesheet requires either an XSLT-1.0 processor with node-set()
  extension function, or an XSLT-2.0 processor. Therefore, parts of the
  document couldn't be displayed.
</p></body></html>