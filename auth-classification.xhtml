<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/TR/2001/REC-MathML2-20010221/dtd/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="GENERATOR" content="LyX 2.0.0" />
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>A Proposals for Classification and Analysis of HTTPbis Authentication Proposals</title>

<!-- Text Class Preamble -->
<style type="text/css">
div.toc {
margin: 2em 0em;
border-style: solid;
border-width: 2px 0px;
padding: 1em 0em;
}
div.tochead { font-size: x-large; font-weight: bold; }
div.lyxtoc-0 {
margin: 2em 0em 0em 0em;
font-size: xx-large;
font-weight: bold;
}
div.lyxtoc-1 {
margin: 1em 0em 0em 0em;
font-size: x-large;
font-weight: bold;
}
div.lyxtoc-2 {
margin: 0em 0em 0em 1em;
font-size: large;
font-weight: normal;
}
div.lyxtoc-3 { margin: 0em 0em 0em 0.5em; font-size: medium; }
div.lyxtoc-4 { margin: 0em 0em 0em 0.5em; }
div.lyxtoc-5 { margin: 0em 0em 0em 0.5em; }
div.lyxtoc-6 { margin: 0em 0em 0em 0.5em; }
a.tocentry {
text-decoration: none;
color: black;
}
a.tocentry:visited { color: black; }
a.tocarrow {
font-weight: bold;
text-decoration: none;
color: #909090;
}
a.tocarrow:visited { color: #C0C0C0; }
</style>

<!-- Preamble Snippets -->

<!-- Layout-provided Styles -->
<style type='text/css'>
h1.title {
font-size: x-large;
margin-bottom: 1ex;
text-align: center;

}
div.standard {
text-align: left;

}
div.plain_layout {
text-align: left;

}
div.author {
font-size: large;
margin-top: 1.3ex;
margin-bottom: 0.7ex;
text-align: center;

}
div.abstract {
font-size: small;
margin-top: 0.7ex;
margin-bottom: 0.7ex;
margin-left: 3ex;
margin-right: 3ex;
text-align: left;

}
div.abstract_label {
font-weight: bold;
font-size: large;
text-align: center;

}

div.abstract {
margin: 4ex;
}
div.abstract_item {
font-size: small;
padding-top: 1ex;
}
div.abstract_label {
font-weight: bold;
}
h2.section {
font-weight: bold;
font-size: x-large;
margin-top: 1.3ex;
margin-bottom: 0.7ex;
text-align: left;

}
h3.subsection {
font-weight: bold;
font-size: large;
margin-top: 0.9ex;
margin-bottom: 0.5ex;
text-align: left;

}
dl.description dt { font-weight: bold; }
div.revisionremark {
text-align: left;

}
ul.itemize {
margin-top: 0.7ex;
margin-bottom: 0.7ex;
margin-left: 3ex;
text-align: left;

}
ol.enumerate {
margin-top: 0.7ex;
margin-bottom: 0.7ex;
margin-left: 3ex;
text-align: left;

}
h4.subsubsection {
font-weight: bold;
font-size: medium;
margin-top: 0.7ex;
margin-bottom: 0.4ex;
text-align: left;

}
div.bibliography {
text-align: left;

}
div.flex_docname {
font-family: serif;
font-weight: normal;
font-style: normal;
font-variant: normal;
font-size: medium;
}
div.flex_ipr {
font-family: serif;
font-weight: normal;
font-style: normal;
font-variant: normal;
font-size: medium;
}
div.flex_intendedstatus {
font-family: serif;
font-weight: normal;
font-style: normal;
font-variant: normal;
font-size: medium;
}
div.flex_titleabbrev {
font-family: serif;
font-weight: normal;
font-style: normal;
font-variant: normal;
font-size: medium;
}
div.flex_ietfarea {
font-family: serif;
font-weight: normal;
font-style: normal;
font-variant: normal;
font-size: medium;
}
div.flex_xml_rfckeyword {
font-family: serif;
font-weight: normal;
font-style: normal;
font-variant: normal;
font-size: medium;
}
div.flex_pi {
font-family: serif;
font-weight: normal;
font-style: normal;
font-variant: normal;
font-size: medium;
}
div.flex_authororg {
font-family: serif;
font-weight: normal;
font-style: normal;
font-variant: normal;
font-size: medium;
}
div.flex_authororgabbrev {
font-family: serif;
font-weight: normal;
font-style: normal;
font-variant: normal;
font-size: medium;
}
div.flex_authoremailaddr {
font-family: serif;
font-weight: normal;
font-style: normal;
font-variant: normal;
font-size: medium;
}
div.float {
border: 2px solid black;
text-align: center;
}
div.listings {
font-family: monospace;
}
div.float-caption {
text-align: center;
border: 2px solid black;
padding: 1ex;
margin: 1ex;
}
div.flex_referenceentity {
font-family: serif;
font-weight: normal;
font-style: normal;
font-variant: normal;
font-size: medium;
}
</style>
</head>
<body>
<h1 class="title"><a id='magicparlabel-1' />
A Proposals for Classification and Analysis of HTTPbis Authentication Proposals</h1>
<div class="standard"><a id='magicparlabel-2' />
<div class="flex_docname"><div class="plain_layout"><a id='magicparlabel-6' />
draft-williams-httpbis-auth-classification</div>
</div><div class="flex_ipr"><div class="plain_layout"><a id='magicparlabel-10' />
trust200902</div>
</div><div class="flex_intendedstatus"><div class="plain_layout"><a id='magicparlabel-14' />
Informational</div>
</div><div class="flex_titleabbrev"><div class="plain_layout"><a id='magicparlabel-18' />
HTTPbis Auth Classification</div>
</div><div class="flex_ietfarea"><div class="plain_layout"><a id='magicparlabel-22' />
Security Area</div>
</div><div class="flex_xml_rfckeyword"><div class="plain_layout"><a id='magicparlabel-26' />
Internet-Draft</div>
</div><div class="flex_pi"><div class="plain_layout"><a id='magicparlabel-30' />
tocindent="no"</div>
</div><div class="flex_pi"><div class="plain_layout"><a id='magicparlabel-34' />
comments="yes"</div>
</div><div class="flex_pi"><div class="plain_layout"><a id='magicparlabel-38' />
inline="yes"</div>
</div></div>

<div class="author"><div class="author_item"><a id='magicparlabel-39' />
Nicolas Williams<div class="flex_authororg"><div class="plain_layout"><a id='magicparlabel-43' />
Cryptonector, LLC</div>
</div><div class="flex_authororgabbrev"><div class="plain_layout"><a id='magicparlabel-47' />
Cryptonector</div>
</div><div class="flex_authoremailaddr"><div class="plain_layout"><a id='magicparlabel-51' />
nico@cryptonector.com</div>
</div></div>
</div>

<div class="abstract"><div class="abstract_label">Abstract</div>
<div class="abstract_item"><a id='magicparlabel-52' />
This document proposes a classification scheme for HTTPbis authentication proposals, to help with analysis and selection.</div>
</div>
<div class="standard"><a id='magicparlabel-53' />
</div>
<div class='toc'><div class='tochead part_'>Table of Contents</div>

<div class='lyxtoc-1'><a href='#magicparlabel-54' class='tocentry'>1 Introduction</a> <a href='#magicparlabel-54' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-58' class='tocentry'>1.1 Conventions used in this document</a> <a href='#magicparlabel-58' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-60' class='tocentry'>1.2 Scope</a> <a href='#magicparlabel-60' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-63' class='tocentry'>1.3 Glossary</a> <a href='#magicparlabel-63' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-86' class='tocentry'>2 Background</a> <a href='#magicparlabel-86' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-108' class='tocentry'>2.1 Threat Models</a> <a href='#magicparlabel-108' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-110' class='tocentry'>2.2 On Trust</a> <a href='#magicparlabel-110' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-112' class='tocentry'>2.3 On Mutual Authentication and URI Schemes</a> <a href='#magicparlabel-112' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-114' class='tocentry'>2.4 On Authentication Mechanism Message Counts</a> <a href='#magicparlabel-114' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-117' class='tocentry'>2.5 On Channel Binding and One-Message Authentication Mechanisms</a> <a href='#magicparlabel-117' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-123' class='tocentry'>2.6 Logon Sessions</a> <a href='#magicparlabel-123' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-125' class='tocentry'>2.7 Web Cookies, a Form of Bearer Tokens</a> <a href='#magicparlabel-125' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-127' class='tocentry'>2.8 User Interface Issues</a> <a href='#magicparlabel-127' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-129' class='tocentry'>3 Classification Axes</a> <a href='#magicparlabel-129' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-143' class='tocentry'>3.1 Dependence on TLS Server PKI</a> <a href='#magicparlabel-143' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-146' class='tocentry'>3.2 Bearer Tokens vs. Proof of Possession</a> <a href='#magicparlabel-146' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-149' class='tocentry'>3.3 Layer at which Authentication Protocol Operates</a> <a href='#magicparlabel-149' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-161' class='tocentry'>3.3.1 HTTP- vs. Application-Layer Authentication in the Network Stack</a> <a href='#magicparlabel-161' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-308' class='tocentry'>3.3.2 HTTP- vs. Application-Layer Authentication in the API Stack</a> <a href='#magicparlabel-308' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-311' class='tocentry'>3.3.3 Choice of Layer</a> <a href='#magicparlabel-311' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-316' class='tocentry'>3.3.4 User Authentication in the TLS Layer</a> <a href='#magicparlabel-316' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-329' class='tocentry'>3.4 Party Responsible for Infrastructure Messaging</a> <a href='#magicparlabel-329' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-336' class='tocentry'>3.5 Number of Messages</a> <a href='#magicparlabel-336' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-359' class='tocentry'>3.6 Trust Establishment</a> <a href='#magicparlabel-359' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-379' class='tocentry'>3.7 Threat Modeling</a> <a href='#magicparlabel-379' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-381' class='tocentry'>3.8 Explicit versus Implisit Session Management</a> <a href='#magicparlabel-381' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-383' class='tocentry'>3.9 In-Band versus Out-of-Band Authentication</a> <a href='#magicparlabel-383' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-385' class='tocentry'>4 Analysis of Some Possible Authentication Proposals</a> <a href='#magicparlabel-385' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-1'><a href='#magicparlabel-400' class='tocentry'>5 Author's Recommendations</a> <a href='#magicparlabel-400' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-1'><a href='#magicparlabel-416' class='tocentry'>6 References</a> <a href='#magicparlabel-416' class='tocarrow'>&gt;</a></div>
</div>

<h2 class="section"><span class="section_label">1</span> <a id='magicparlabel-54' />
Introduction</h2>
<div class="standard"><a id='magicparlabel-55' />
The HTTPbis WG is accepting proposals for new authentication systems for HTTPbis, the successor to Hypertext Transport Protocol (HTTP) version 1.1[<a href='#key-3'>key-3</a>]. This document proposes a classification system for these proposals. Several axes of classification are proposed, and several simplified imagined or likely authentication systems are used to illustrate the classification system.</div>

<div class="standard"><a id='magicparlabel-56' />
The author assumes that the WG is interested primarily in new user authentication proposals, with ones that provide mutual authentication (of users and servers to each other) being in scope. The author also assumes that Transport Layer Security (TLS) [<a href='#key-2'>key-2</a>] will continue to be used by HTTPbis for cryptographic session protection.</div>

<div class="standard"><a id='magicparlabel-57' />
Some familiarity with authentication systems is assumed. A glossary is provided.</div>
<h3 class="subsection"><span class="subsection_label">1.1</span> <a id='magicparlabel-58' />
Conventions used in this document</h3>
<div class="standard"><a id='magicparlabel-59' />
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [<a href='#key-1'>key-1</a>].</div>
<h3 class="subsection"><span class="subsection_label">1.2</span> <a id='magicparlabel-60' />
Scope</h3>
<div class="standard"><a id='magicparlabel-61' />
This document considers user authentication only in the context of HTTP applications, whether they be web applications or otherwise. Authentication of the service is also in scope, but authentication methods that authenticate only the user to the service (with the service authenticated by Transport Layer Security (TLS)) are in scope.</div>

<div class="standard"><a id='magicparlabel-62' />
There are at least two entities involved in authentication in this context: the user (on the client side), one or more of the web server host or the web server application/service, and any trusted third parties that an authentication mechanism might involve.</div>
<h3 class="subsection"><span class="subsection_label">1.3</span> <a id='magicparlabel-63' />
Glossary</h3>
<div class="standard"><a id='magicparlabel-64' />
This section defines terms as they are used in this document.</div>

<dl class='description'><dt class="description_label">API</dt>
<dd class="description_item"><a id='magicparlabel-65' />
 Application Programming Interface. These are interfaces between an application and a feature that is abstracted into a &ldquo;library&rdquo; &ndash; a service provided by the platform's operating system.</dd>
<dt class="description_label">API&nbsp;Layer</dt>
<dd class="description_item"><a id='magicparlabel-66' />
 A complex Internet application might require a large number of APIs, such as, for example, one for every network layer. In practice it is more common to have a single API that encompasses all network layers below it, with the component providing that API likely invoking other APIs itself. which in turn invoke other APIs. For example, a web application might use a library that presents a single API to all of the HTTP network stack from HTTP all the way down to IP. Note that there need not be a direct correspondence of network and API layers.</dd>
<dt class="description_label">Authentication</dt>
<dd class="description_item"><a id='magicparlabel-67' />
 The process of establishing the veracity or origin of some statement (e.g., of an entity's identity), usually by proxy (e.g., with keypairs to an asymmetric key cryptographic system &ldquo;speaking for&rdquo; the authenticated entities). In this document, and unless otherwise stated, &ldquo;authentication&rdquo; will refer to authentication of identity of entities such as &ldquo;users&rdquo;, &ldquo;hosts&rdquo;, and &ldquo;services&rdquo;.</dd>
<dt class="description_label">Authentication&nbsp;Mechanism</dt>
<dd class="description_item"><a id='magicparlabel-68' />
 A cryptographic protocol for authenticating entity identities. Note that this does not cover POSTing usernames and passwords in forms, but it does cover bearer token mechanisms (if just barely).</dd>
<dt class="description_label">Authentication&nbsp;Method</dt>
<dd class="description_item"><a id='magicparlabel-69' />
 A scheme for authenticating entity identities. An authentication method can be non-cryptographic, covering HTTP Basic authentication and usernames&amp;passwords POSTed from HTML forms.</dd>
<dt class="description_label">Authentication&nbsp;Framework</dt>
<dd class="description_item"><a id='magicparlabel-70' />
 A protocol into which other authentication mechanisms may be plugged in. For example: SASL[<a href='#key-9'>key-9</a>], GSS-API[<a href='#key-13'>key-13</a>], EAP[<a href='#key-12'>key-12</a>], among others.</dd>
<dt class="description_label">Bearer&nbsp;Token</dt>
<dd class="description_item"><a id='magicparlabel-71' />
 A technique for authentication that involves a message that can be presented by the authenticating entity to another. No proof of possession is required for using bearer tokens, which means that the token can be presented by any entity possessing the token, which in turn means that bearer tokens must be sent with confidentiality protection, as otherwise eavesdroppers can steal them and use them to impersonate the subject.</dd>
<dt class="description_label">Channel&nbsp;Binding</dt>
<dd class="description_item"><a id='magicparlabel-72' />
 A security protocol composition and analysis tool. The purpose of channel binding[<a href='#key-4'>key-4</a>] is to &ldquo;bind&rdquo; a secure channel (at one layer in the network stack) into an authentication protocol running at a higher layer in the stack, thereby ensuring that the channel is end-to-end and &ldquo;speaks for&rdquo; its end-points.</dd>
<dt class="description_label">Confidentiality&nbsp;protection</dt>
<dd class="description_item"><a id='magicparlabel-73' />
 Cryptographic encryption of data. Confidentiality protection is/must always be used with integrity protection as well.</dd>
<dt class="description_label">Data&nbsp;authentication</dt>
<dd class="description_item"><a id='magicparlabel-74' />
 Data origin authentication, a.k.a., integrity protection.</dd>
<dt class="description_label">Integrity&nbsp;protection</dt>
<dd class="description_item"><a id='magicparlabel-75' />
 Cryptographic protection against modification of data. See also &ldquo;data authentication&rdquo;, above.</dd>
<dt class="description_label">Mechanism</dt>
<dd class="description_item"><a id='magicparlabel-76' />
 Shorthand for &ldquo;authentication mechanism&rdquo;, a protocol defining messages to be exchanged in order to authenticate one party to another (or two parties to each other).</dd>
<dt class="description_label">Mutual&nbsp;Authentication</dt>
<dd class="description_item"><a id='magicparlabel-77' />
 Authentication of a user and a server/service to each other.</dd>
<dt class="description_label">Mutual&nbsp;Authentication&nbsp;(key&nbsp;confirmation&nbsp;sense)</dt>
<dd class="description_item"><a id='magicparlabel-78' />
 In some protocols key exchange is bound to authentication of the service to the user such that the service is finally authenticated when it sends a proof-of-possession of the exchanged session key back to the user. Protocols that use RSA key transport (e.g., TLS in common usage), Diffie-Hellman with a persistent public key for the server, or Needham-Schroeder protocols (such as Kerberos[<a href='#key-5'>key-5</a>]), perform server authentication in this way. A client may not always care to receive key confirmation. For example, a Kerberos client for a lossy logging application might not care that confidentiality protected data ends up at the wrong server, as long as unintended servers can't decrypt the data. Some clients may send application data optimistically ahead of key confirmation from the server. Such data should generally be confidentiality protected, and the protocol should not be subject to MITM attacks where the MITM can somehow modify what optimistic data is sent, nor should an active attacker be able to replay such optimistic data.</dd>
<dt class="description_label">Network&nbsp;Layer</dt>
<dd class="description_item"><a id='magicparlabel-79' />
 A layer in the OSI or Internet network model. Examples of layers that are relevant to HTTP applications: IP, TCP/UDP, TLS, HTTP, and the application layer.</dd>
<dt class="description_label">Proof&nbsp;of&nbsp;Possession</dt>
<dd class="description_item"><a id='magicparlabel-80' />
 A technique for authentication that involves using a cryptographic operation to &ldquo;prove&rdquo; (not necessarily in a rigorous sense) that the entity that creates the proof has access to a private/secret key to a cryptosystem (e.g., a private RSA key, a secret AES key, etcetera).</dd>
<dt class="description_label">Public&nbsp;Key&nbsp;Infrastructure&nbsp;(PKI)</dt>
<dd class="description_item"><a id='magicparlabel-81' />
 An authentication system based on public key cryptography and supporting hierarchical transitive trust via trusted third parties known as Certificate Authorities (CAs).</dd>
<dt class="description_label">SCRAM</dt>
<dd class="description_item"><a id='magicparlabel-82' />
 Salted Challenge Response Authentication Mechanism (SCRAM)[<a href='#key-10'>key-10</a>], a SASL[<a href='#key-9'>key-9</a>] and GSS mechanism based on password-derived pre-shared keys and challeng/response. SCRAM is intended as the successor to SASL's DIGEST-MD5, and possibly to HTTP's DIGEST-MD5.</dd>
<dt class="description_label">Server</dt>
<dd class="description_item"><a id='magicparlabel-83' />
 A system with one or more IP addresses, serving HTTP on one more TCP ports on those IP addresses. [A general definition would not be constrained to HTTP only, but for the purposes of this document this is good enough.]</dd>
<dt class="description_label">Service</dt>
<dd class="description_item"><a id='magicparlabel-84' />
 An entity providing a service or services for an application. Typically -but not always!- a service is closely related to a host server, which may provide several services. Usually we need to distinguish between the various services that a single host provides, thus we often need to authenticate the <em>service</em> rather than the host server. For HTTP applications a service may be a collection of resources available on one (or more) ports on a given server.</dd>
</dl>
<div class="revisionremark"><a id='magicparlabel-85' />
Fill out! Add some entries for OAuth, Kerberos, Basic, DIGEST-MD5, EAP, GSS, SASL, ...</div>
<h2 class="section"><span class="section_label">2</span> <a id='magicparlabel-86' />
Background</h2>
<div class="standard"><a id='magicparlabel-87' />
Web applications today use a variety of user authentication methods, many of which are somewhat or deeply unsatisfying. Almost all of these methods involve the user-agent being mostly dumb &ndash; not participating in any cryptographic protocols other than TLS.</div>

<div class="standard"><a id='magicparlabel-88' />
The most common user authentication methods used in web applications today include:</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-89' />
Username and password POSTed to the serverfrom an HTML form. Usually the URL to post to is an HTTPS URL. Not as often the URL of the HTML page containing the form is also an HTTPS URL.</li>
<li class="itemize_item"><a id='magicparlabel-90' />
HTTP Basic or DIGEST-MD5 authentication.</li>
<li class="itemize_item"><a id='magicparlabel-91' />
Out-of-band methods:

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-92' />
PINs sent to user devices via SMS (POSTed along with passwords)</li>
<li class="itemize_item"><a id='magicparlabel-93' />
OTP tokens (POSTed along with passwords)</li>
<li class="itemize_item"><a id='magicparlabel-94' />
login URLs e-mailed to the user</li>
<li class="itemize_item"><a id='magicparlabel-95' />
passwords e-mailed to the user</li>
</ul>
</li></ul>
<div class="standard"><a id='magicparlabel-96' />
Not much use is made of TLS user certificates, though that is available as well.</div>

<div class="standard"><a id='magicparlabel-97' />
These methods are somewhat-to-highly unsatisfactory for a variety of reasons:</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-98' />
Users have to remember/carry too many passwords, even when they have many fewer &ldquo;identities&rdquo; (typically in the form of e-mail addresses).

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-99' />
Credential sharing becomes a problem: compromise of one site can result in compromise of user accounts at unrelated sites. Also, a malicious site posing as a friendly site can do the same.</li>
</ul>
</li><li class="itemize_item"><a id='magicparlabel-100' />
The service is generally not authenticated to the user. TLS does authenticate the server, but not necessarily the service, and anyways only to the best of the TLS server PKI's ability.

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-101' />
This problem derives in part from the nature of the HTTP URI scheme: by identifying server hosts rather than services the HTTP URI scheme fails to provide the user and user-agent with enough information by which to identify, and thence authenticate, a service. New URI schemes may be required.</li>
</ul>
</li><li class="itemize_item"><a id='magicparlabel-102' />
OTP and out-of-band methods do not protect against MITMs, and thus depend on the integrity of TLS and the TLS server PKI.</li>
<li class="itemize_item"><a id='magicparlabel-103' />
HTTP/Negotiate[<a href='#key-14'>key-14</a>], which effectively uses GSS-API[<a href='#key-13'>key-13</a>] mechanisms, usually NTLM [XXX Add reference] or Kerberos[<a href='#key-5'>key-5</a>, <a href='#key-15'>key-15</a>].</li>
</ul>
<div class="standard"><a id='magicparlabel-104' />
Additionally, there is no strong concept of &ldquo;sessions&rdquo; in web applications. Sessions, such as they are, consist of HTTP requests and responses united into a session by the web cookies they bear. Not all web cookies are used for identifying sessions, and there is no simple &ldquo;logout&rdquo; functionality. The biggest problem with web cookies is that they are too easy to misuse or steal (e.g., given the occasional TLS vulnerability, such as BEAST [XXX Add references!]).</div>

<div class="standard"><a id='magicparlabel-105' />
Furthermore, there are uncomfortable user interface (UI) problems. In particular it is difficult to convey to the user information about the server's/service's identity and how it is authenticated (if at all).</div>

<div class="standard"><a id='magicparlabel-106' />
HTTP applications that are not web application have similar issues, though some of them can also use SASL[<a href='#key-9'>key-9</a>]. Non-web HTTP applications also may not need cookies, instead using a single HTTP/1.1 persistent connection over which to issue all requests that make up a session &ndash; such applications have a stronger sense of session than web applications do.</div>

<div class="revisionremark"><a id='magicparlabel-107' />
XXX Finish this section.</div>
<h3 class="subsection"><span class="subsection_label">2.1</span> <a id='magicparlabel-108' />
Threat Models</h3>
<div class="revisionremark"><a id='magicparlabel-109' />
Talk about threat models and which are appropriate for HTTPbis. Discuss the Internet threat model and its flaws (namely/primarily, the local security assumption).</div>
<h3 class="subsection"><span class="subsection_label">2.2</span> <a id='magicparlabel-110' />
On Trust</h3>
<div class="revisionremark"><a id='magicparlabel-111' />
Describe issues w.r.t. &ldquo;trust&rdquo;, such as transitivity, introductions, and so on. This is important for evaluating proposals. A proposal that replaces the TLS server PKI's primacy with... another system with similar transitive trust issues may not be a useful proposal. On the other hand, it seems impossible to avoid transitive trust when scaling to Internet scale. Understanding this may help, for example, give impetus to improvements to the TLS server PKI, or it may guide replacements, understand scalability, and so on.</div>
<h3 class="subsection"><span class="subsection_label">2.3</span> <a id='magicparlabel-112' />
On Mutual Authentication and URI Schemes</h3>
<div class="revisionremark"><a id='magicparlabel-113' />
Describe the limitations imposed by the Internet threat model when there is no mutual authentication. Describe the two types/senses of mutual authentication: authenticating the server (in addition to the client) and key confirmation. Describe the limitations, imposed by the HTTP URI scheme, on service identification and authentication.</div>
<h3 class="subsection"><span class="subsection_label">2.4</span> <a id='magicparlabel-114' />
On Authentication Mechanism Message Counts</h3>
<div class="standard"><a id='magicparlabel-115' />
All authentication mechanism require some number of messages in order to authenticate an entity. For example, TLS generally requires two round-trips, while OAuth requires a single message from the client to the server. Here we count only messages from the HTTP client to the HTTP server; additional message exchanges may be required involving trusted third parties.</div>

<div class="revisionremark"><a id='magicparlabel-116' />
...</div>
<h3 class="subsection"><span class="subsection_label">2.5</span> <a id='magicparlabel-117' />
On Channel Binding and One-Message Authentication Mechanisms</h3>
<div class="standard"><a id='magicparlabel-118' />
Channel binding [<a href='#key-4'>key-4</a>] is the act of binding authentication at one network layer to key exchange at a lower network layer. When this occurs within the same layer we don't call it channel binding, but the same concept is involved. For example, TLS PSK and user certificates are cryptographically bound to whatever key exchange method is used, but because this happens naturally within TLS we don't call it channel binding. [Expand on this for the benefit of those not familiar with RFC5056.]</div>

<div class="standard"><a id='magicparlabel-119' />
Normally channel binding requires mutual authentication, either in the key confirmation sense or in the sense of actually authenticating the server. In order to see why imagine a one-message user authentication system: a man-in-the-middle (MITM) at a lower layer might be able to steal this one message, close the connection to the real client, then impersonate the client to the server. There are ways of preventing this, but they are not as general as requiring mutual authentication is.</div>

<div class="standard"><a id='magicparlabel-120' />
At one point a SASL mechanism, &ldquo;YAP&rdquo;, was proposed that requires just one message and provides channel binding. In order to prevent the message theft problem described above YAP requires that tls-unique channel bindings be used, which effectively eliminates MITMs at the TLS layer. At the time the SASL community rejected this proposal, mostly on account of not wanting to have SASL be aware of the type of channel bindings data used by the application. In retrospect, however, the idea has merit.</div>

<div class="standard"><a id='magicparlabel-121' />
Now consider an authentication system that begins life as a bearer token and later is upgraded to be a bearer token that is encrypted in the server's public key, the same public key as is expected to be used by the server in TLS. This bearer token can still be stolen and used by the thief... unless the TLS client knows to ensure that the same public key is used at both layers. But how might the client know how to do that? If the client passes the server's certificate to the client's IdP then the most the IdP can do is apply certificate validation, including certificate/CA/public key pinning options; if the IdP doesn't do this then the MITM will be able to decrypt the bearer token and then re-encrypt it in the real server's public key. This can be overcome by having the IdP do better certificate validation or knowing the target server's certificate a priori, with all the same problems as the traditional TLS server PKI (which is not necessarily a problem). It's not clear how one might successfully apply unique or client end-point channel bindings to a bearer token authentication system, but if there's a way to do so it would help.</div>

<div class="standard"><a id='magicparlabel-122' />
YAP is a proof-of-possession mechanism, of course, thus it is quite simple to apply channel binding types other than server end-point, thus making YAP secure against message theft and re-use where a bearer token system could not be. The point being that a secure half round trip (one message) user authentication mechanism is feasible.</div>
<h3 class="subsection"><span class="subsection_label">2.6</span> <a id='magicparlabel-123' />
Logon Sessions</h3>
<div class="revisionremark"><a id='magicparlabel-124' />
Discuss the binding of HTTP requests (and responses) to logon sessions. Discuss logout.</div>
<h3 class="subsection"><span class="subsection_label">2.7</span> <a id='magicparlabel-125' />
Web Cookies, a Form of Bearer Tokens</h3>
<div class="revisionremark"><a id='magicparlabel-126' />
Discuss cookies as a form of bearer token and how the situation is not as dire as with bearer tokens for user authentication. Discuss alternatives based on MACing portions (or all) of the HTTP requests (and responses) or the channel bindings data for the TLS channel.</div>
<h3 class="subsection"><span class="subsection_label">2.8</span> <a id='magicparlabel-127' />
User Interface Issues</h3>
<div class="revisionremark"><a id='magicparlabel-128' />
Discuss phishing issues, in particular the difficult of creating user interfaces in web apps that cannot be spoofed by either server impersonators or MITMs. Reference Sam Hartman's anti-phishing I-D [<a href='#key-7'>key-7</a>].</div>
<h2 class="section"><span class="section_label">3</span> <a id='magicparlabel-129' />
Classification Axes</h2>
<div class="standard"><a id='magicparlabel-130' />
Several orthogonal classification axes are proposed:</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-131' />
Dependence on/independence of the TLS server PKI;</li>
<li class="enumerate_item"><a id='magicparlabel-132' />
Solutions based on bearer tokens vs. ones based on proof of possession;</li>
<li class="enumerate_item"><a id='magicparlabel-133' />
Layer at which user authentication takes place: TLS, HTTPbis, or the application layer;</li>
<li class="enumerate_item"><a id='magicparlabel-134' />
Whether the client, the server, or both, engage in infrastructure messaging;</li>
<li class="enumerate_item"><a id='magicparlabel-135' />
Number of messages exchanged / &ldquo;round trips&rdquo;;</li>
<li class="enumerate_item"><a id='magicparlabel-136' />
Trust establishment: pair/group-wise non-transitive, federated or otherwise transitive, hierarchical vs. mesh;</li>
<li class="enumerate_item"><a id='magicparlabel-137' />
Threat modeling;</li>
<li class="enumerate_item"><a id='magicparlabel-138' />
Explicit versus implicit session management;</li>
<li class="enumerate_item"><a id='magicparlabel-139' />
In-band / out-of-band.</li>
<li class="enumerate_item"><a id='magicparlabel-140' />
[Maybe add something about separation of password verifier access, to limit the attack surface area for password recovery?]</li>
</ol>
<div class="revisionremark"><a id='magicparlabel-141' />
Note: The author assumes that all acceptable proposals will have HTTPbis continue to depend on TLS for transport security &ndash; for confidentiality (encryption) and integrity (authentication) protection of data exchanged by the HTTPbis client and server. If this assumption is incorrect then we can add one more axis of classification: dependence on / independence of TLS.</div>

<div class="standard"><a id='magicparlabel-142' />
These nine classification axes are largely orthogonal to each other. Other classification criteria are also possible and may be added in future versions of this Internet-Draft. Some such possible additional criteria are subjective, such as, for example: ease of deployment, ease of implementation, etcetera. Perhaps the WG can come to consensus regarding desirable properties based on objective classification to narrow the set of proposals to consider. Or perhaps the WG can consider a large number of proposals and use objective classification to guide any applicability statements for the proposals accepted. Ideally the WG can apply objective classification first, then for each &ldquo;bucket&rdquo; of similar proposals the WG could consider more subjective classification criteria.</div>
<h3 class="subsection"><span class="subsection_label">3.1</span> <a id='magicparlabel-143' />
Dependence on TLS Server PKI</h3>
<div class="standard"><a id='magicparlabel-144' />
The web today depends utterly on the &ldquo;TLS server PKI&rdquo; for security. This would be just fine were it not for the systemic weaknesses in the TLS server PKI: the lack of name constraints, the large number of trust anchors, the large number of certificate authority (CA) compromises, and so on. Building on the TLS server PKI and thus assuming its being sufficiently secure, is quite tempting, as it may simplify various aspects of user authentication (not least by providing server authentication a priori, thus saving the designers the need to provide server authentication themselves).</div>

<div class="standard"><a id='magicparlabel-145' />
This classification axis is very simple: either a proposed solution depends on the TLS server PKI or it doesn't. Some shades of black are imaginable in this case (if not likely).</div>
<h3 class="subsection"><span class="subsection_label">3.2</span> <a id='magicparlabel-146' />
Bearer Tokens vs. Proof of Possession</h3>
<div class="standard"><a id='magicparlabel-147' />
A bearer token is a message the presentation of which is sufficient to authenticate the presenter. Stolen bearer tokens may be used to trivially impersonate the subject, thus bearer tokens generally require confidentiality protection in any protocols over which they might be exchanged, and generally depend on authenticating the relying party first.</div>

<div class="standard"><a id='magicparlabel-148' />
Proof of possession systems consist of some secret/private key(s), an authenticator message the &ldquo;proves&rdquo; possession of the secret or private key(s) used in the construction of the authenticator, and a token not unlike a bearer token but which securely indicates to the relying party(ies) what keys the user must have used in the construction of the authenticator. The relying party then validates the authenticator to establish that the user did indeed possess the necessary secret/private key(s) to the best of the cryptographic capabilities of the authentication system used.</div>
<h3 class="subsection"><span class="subsection_label">3.3</span> <a id='magicparlabel-149' />
Layer at which Authentication Protocol Operates</h3>
<div class="standard"><a id='magicparlabel-150' />
It is possible to design user (and mutual) authentication mechanisms that can work at any end-to-end layer between the HTTPbis client and server. The relevant layers are:</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-151' />
TLS,</li>
<li class="itemize_item"><a id='magicparlabel-152' />
HTTPbis,</li>
<li class="itemize_item"><a id='magicparlabel-153' />
and the application layer.</li>
</ul>
<div class="standard"><a id='magicparlabel-154' />
We dismiss out of hand the possibility of that layer being TCP or IPsec, though admittedly they are also end-to-end layers where user authentication could theoretically be done.</div>

<div class="standard"><a id='magicparlabel-155' />
We distinguish between network layers and API layers (see glossary). A solution at the application <em>network</em> layer might nonetheless be implemented at the HTTP <em>API</em> layer (and vice-versa).</div>

<div class="standard"><a id='magicparlabel-156' />
User authentication is generally something that a transport layer cannot know to initiate on its own: the application must be in control of when (server- and client-side) to authenticate, how (server- and/or client-side), with what credentials / as whom (client-side). This means that authentication in the transport layer requires APIs that give the application a measure of control. HTTP API capabilities will vary, but HTTPbis is a good opportunity to standardize an abstract API outlining capabilities and semantics to be exposed to applications by an HTTP stack.</div>

<div class="standard"><a id='magicparlabel-157' />
Note that on the user-agent side the platform may provide user interaction facilities for authentication, thus simplifying user authentication APIs. The application, on the server side, remains in control over when to initiate authentication.</div>

<div class="standard"><a id='magicparlabel-158' />
End-to-end session cryptographic protection is best done in the lowest possible transport layer. For HTTP applications, historically this means TLS; though it'd be technically feasible to provide protection at lower layers it does not appear to be a realistic option at this time.</div>

<div class="standard"><a id='magicparlabel-159' />
User authentication is best &ldquo;bound&rdquo; into transport security layers, in this case TLS. When user authentication is moved to higher layers a &ldquo;channel binding&rdquo; problem arises: we would like to ensure that no man-in-the-middle exists in the transport layer, with the MITM terminating two TLS connections. For more information about channel binding see [<a href='#key-4'>key-4</a>].</div>

<div class="standard"><a id='magicparlabel-160' />
UI and API issues are quite different for web applications versus non-web applications. The former have rich UI elements (all of HTML's) and programming models (scripting, particularly through JavaScript). One problem that is particularly severe for web applications, is the ability of server impersonators to emulate all imaginable graphical user interfaces that the native user-agent might wish to use to distinguish itself from the applications it runs. Regardless of what layer implements authentication this problem will arise in web applications.</div>
<h4 class="subsubsection"><span class="subsubsection_label">3.3.1</span> <a id='magicparlabel-161' />
HTTP- vs. Application-Layer Authentication in the Network Stack</h4>
<div class="standard"><a id='magicparlabel-162' />
It's important to note that there need not be much difference between HTTP-layer and application-layer user authentication, at least if we assume a standard application-layer user authentication convention. For argument's sake let's assume an application-layer user authentication convention like the one in [<a href='#key-6'>key-6</a>], and let's assume two possible HTTPbis HTTP-layer authentication solutions: one that is most similar to HTTP/1.1's and one that uses a new verb for authentication. Then let's look at what each of these three solutions look like on the wire using the SCRAM mechanism for cases where the client already knows it has to authenticate. For brevity we elide any HTTP request and response where the server indicates that the client must authenticate, as well as any requests/responses involving negotiation of mechanism to use.</div>

<div class="standard"><a id='magicparlabel-163' />
</div>
<div class='float float-figure'><div class="plain_layout"><a id='magicparlabel-167' />
</div>
<div class='float float-listings'><pre>   C-&gt;S: HTTP/1.1 POST /rest-gss-login
         Host: A.example
         Content-Type: application/rest-gss-login
         Content-Length: nnn
 
         SCRAM-SHA-1,,MIC
         n,,n=user,r=fyko+d2lbbFgONRv9qkxdawL
 
   S-&gt;C: HTTP/1.1 201
         Location http://A.example/rest-gss-session-9d0af5f680d4ff46
         Content-Type: application/rest-gss-login
         Content-Length: nnn
 
         C
         r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,
         s=QSXCR+Q6sek8bf92,i=4096
 
   C-&gt;S: HTTP/1.1 POST /rest-gss-session-9d0af5f680d4ff46
         Host: A.example
         Content-Type: application/rest-gss-login
         Content-Length: nnn
 
         c=biws,r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,
         p=v0X8v3Bz2T0CJGbJQyF0X+HI4Ts=
 
   S-&gt;C: HTTP/1.1 200
         Content-Type: application/rest-gss-login
         Content-Length: nnn
 
         A
         v=rmF9pqV8S7suAoZWja4dJRkFsKQ=
 </pre></div>


<div class="plain_layout"><a id='magicparlabel-203' />
<div class='float-caption float-caption-figure'>Figure 1:<div class="plain_layout"><a id='magicparlabel-207' />
REST-GSS Login w/ SCRAM Example</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-208' />
</div>
<div class='float float-figure'><div class="plain_layout"><a id='magicparlabel-212' />
</div>
<div class='float float-listings'><pre>   C-&gt;S: HTTP/1.1 LOGIN
         Host: A.example
         Content-Type: application/SASL
         Content-Length: nnn
 
         SCRAM-SHA-1,,MIC
         n,,n=user,r=fyko+d2lbbFgONRv9qkxdawL
 
   S-&gt;C: HTTP/1.1 201
         Location http://A.example/login-session-9d0af5f680d4ff46
         Content-Type: application/SASL
         Content-Length: nnn
 
         C
         r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,
         s=QSXCR+Q6sek8bf92,i=4096
 
   C-&gt;S: HTTP/1.1 LOGINCONTINUE /login-session-9d0af5f680d4ff46
         Host: A.example
         Content-Type: application/SASL
         Content-Length: nnn
 
         c=biws,r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,
         p=v0X8v3Bz2T0CJGbJQyF0X+HI4Ts=
 
   S-&gt;C: HTTP/1.1 200
         Content-Type: application/SASL
         Content-Length: nnn
 
         A
         v=rmF9pqV8S7suAoZWja4dJRkFsKQ=
 </pre></div>


<div class="plain_layout"><a id='magicparlabel-248' />
<div class='float-caption float-caption-figure'>Figure 2:<div class="plain_layout"><a id='magicparlabel-252' />
HTTPbis w/ New Verb Login w/ SCRAM Example</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-253' />
</div>
<div class='float float-figure'><div class="plain_layout"><a id='magicparlabel-257' />
</div>
<div class='float float-listings'><pre>   C-&gt;S: HTTP/1.1 GET /location/of/interest/to/app
         Host: A.example
 
   S-&gt;C: HTTP/1.1/401 Unauthorized
         Server: HTTPd/0.9
         Date: Sun, 10 Apr 2005 20:26:47 GMT
         WWW-Authenticate: &lt;list of mechanisms&gt;
         Content-Type: text/html
         Content-Length: nnn
 
         &lt;error document&gt;
 
   C-&gt;S: HTTP/1.1 GET /location/of/interest/to/app
         Host: A.example
         Authorization: SCRAM-SHA-1,,MIC
                        n,,n=user,r=fyko+d2lbbFgONRv9qkxdaw
 
   S-&gt;C: HTTP/1.1 4xx
         WWW-Authenticate: C
                           r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,
                           s=QSXCR+Q6sek8bf92,i=4096
         WWW-Authenticate-Session: 9d0af5f680d4ff46
 
   C-&gt;S: HTTP/1.1 GET /location/of/interest/to/app
         Host: A.example
         Authorization-Session: 9d0af5f680d4ff46
         Authorization: c=biws,r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,
                        p=v0X8v3Bz2T0CJGbJQyF0X+HI4Ts=
 
   S-&gt;C: HTTP/1.1 200
         WWW-Authenticate: A
                           v=rmF9pqV8S7suAoZWja4dJRkFsKQ=
         Content-Type: ...
         Content-Length: nnn
 
         &lt;content&gt;
  </pre></div>


<div class="plain_layout"><a id='magicparlabel-298' />
<div class='float-caption float-caption-figure'>Figure 3:<div class="plain_layout"><a id='magicparlabel-302' />
Extended HTTP/1.1 Style Login w/ SCRAM Example</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-303' />
There's not much difference between the first two examples. The third example jas several important differences relative to the first two examples:</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-304' />
The URL is sent to the server before any chance to have completed mutual authentication, should the selected mechanism provide mutual authentication. If the client knows a priori to authenticate and the URL contains sensitive information then the client has no choice but to leak this information prior to completing mutual authentication, thus the client becomes dependent on TLS for authenticating the server even when the client could authenticate the server more strongly via the selected HTTP authentication mechanism. This is an important weakness.</li>
<li class="itemize_item"><a id='magicparlabel-305' />
The whole sequence involves multiple requests/responses, which goes against the stateless nature of HTTP. State is needed in all three examples, but the first example is RESTful, while the second employs a would-be new verb that provides for stateful authentication. The third example simply cannot be thought of as remotely RESTful. Perhaps this is not a problem.

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-306' />
Alternatively mechanisms requiring multiple round trips can be ruled out of scope. This would rule out quite a few desirable mechanisms!</li>
</ul>
</li></ul>
<div class="standard"><a id='magicparlabel-307' />
The main difference on the wire between a generic HTTP-layer user authentication framework (like the one in the second example) and an application-layer equivalent (as in the first example) can be so minimal as to make the choice of layer seem like splitting hairs.</div>
<h4 class="subsubsection"><span class="subsubsection_label">3.3.2</span> <a id='magicparlabel-308' />
HTTP- vs. Application-Layer Authentication in the API Stack</h4>
<div class="standard"><a id='magicparlabel-309' />
There are HTTP stacks that make it possible to implement HTTP authentication methods in the application (e.g., FCGI in web servers), and nothing would prevent HTTP stacks from implementing a <em>standard</em> application-layer user authentication protocol either. The APIs offered by an HTTP stack should look remarkably similar regardless of which layer the user authentication protocol is technically at. Once again, the difference between HTTP-layer and standard application-layer user authentication is minimal.</div>

<div class="standard"><a id='magicparlabel-310' />
Note however that if the HTTP stack does not implement authentication, leaving it to the application to do so, then the application developer runs the risk of making mistakes in the implementation, such as failing to implement channel binding where possible. Thus it is generally best if the HTTP stack implements authentication &ndash; even if TLS is used for user authentication, the HTTP stack should provide a singular API for authentication.</div>
<h4 class="subsubsection"><span class="subsubsection_label">3.3.3</span> <a id='magicparlabel-311' />
Choice of Layer</h4>
<div class="standard"><a id='magicparlabel-312' />
The choice of layer is clearly more important for APIs than on the wire. On the wire the choice of layer is minimal, trivial even, when the choice is between HTTP and the application layer.</div>

<div class="standard"><a id='magicparlabel-313' />
If the WG agrees that the distinction between HTTP-layer and application-layer user authentication is or should be minimal then how should the WG pick one of those two layers, if it decides not to pursue TLS-layer user authentication?</div>

<div class="standard"><a id='magicparlabel-314' />
A standard application-layer authentication scheme implies no changes to HTTP itself, and may not rely on any particular features of HTTP/1.1 or HTTPbis, thus it may be usable even with HTTP/1.0. This is true of the REST-GSS proposal[<a href='#key-6'>key-6</a>], which is also RESTful. This must be of some value.</div>

<div class="standard"><a id='magicparlabel-315' />
An HTTP-layer authentication solution must either: a) not support multi-round trip mechanisms, b) add verbs, or c) not be RESTful. (a) works with HTTP/1.0, (b) would not work with HTTP/1.0. [The author believes that RESTfulness is desirable.]</div>
<h4 class="subsubsection"><span class="subsubsection_label">3.3.4</span> <a id='magicparlabel-316' />
User Authentication in the TLS Layer</h4>
<div class="standard"><a id='magicparlabel-317' />
Issues:</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-318' />
The transport cannot know when to require user authentication (on the server side) or when to initiate it (on the client side). Simply always initiating user authentication creates privacy problems: the user may not want to disclose their identity all the time!</li>
<li class="itemize_item"><a id='magicparlabel-319' />
To address the problem of when to require or initiate user authentication the TLS implementation must provide suitable APIs to the application. And since the application will generally decide that authentication is required only after (possibly well after) a TLS connection is setup, the user generally must be authenticated by renegotiating TLS, which in turn means that two round trips will be needed just for that, at minimum, even if the user authentication mechanism selected requires fewer round trips. This is inefficient, though not fatal.</li>
<li class="itemize_item"><a id='magicparlabel-320' />
The TLS community has resisted proposals for user authentication mechanisms with arbitrary round trip counts before [references? this is in reference to Stefan's TLS-GSS proposal...]. This may no longer be true (or perhaps the author is misunderstanding or misremembering the events in question), but if it is still the case then the range of choices for user authentication in TLS is significantly curtailed.</li>
<li class="itemize_item"><a id='magicparlabel-321' />
Several major TLS implementations defer certificate validation until the peer's Finished message is received. This means that unless one is using TLS renegotiation (with the inner connection's server certificate being the same as in the outer connection's) the user's identity and the payloads related to user authentication will be revealed to the server before the server is authenticated.</li>
<li class="itemize_item"><a id='magicparlabel-322' />
User Interface issues:

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-323' />
A user authentication framework and future mechanisms will likely need to interact with the user. In some cases this may be best done through a platform component, such as a credential management facility. In other cases this may best be done by the application. Driving user interaction from within the TLS layer presents a slight complication: any interaction has to be effected through application- or platform-provided code paths. Adding interaction to existing TLS implementations may not be trivial.</li>
<li class="itemize_item"><a id='magicparlabel-324' />
...</li>
</ul>
</li></ul>
<div class="standard"><a id='magicparlabel-325' />
Benefits:</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-326' />
Where the platform can provide credential management and user interaction then user authentication in TLS can greatly simplify HTTP applications: no user authentication APIs or UIs are then needed in the application.

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-327' />
Note however that the user may have a hard time identifying the context in which they are being prompted by the system for credentials or credential selection. This is usually not a problem in smartphone and other such small devices, where it is generally clear what application is in the foreground, and therefore the context of a prompt. But this is not necessarily so on other platforms.</li>
</ul>
</li><li class="itemize_item"><a id='magicparlabel-328' />
Non-web applications typically know a priori when they wish to authenticate. Typical non-web applications that use HTTP/1.1 over a single TLS connection, with an application session consisting of all the HTTP requests performed over that one connection. For such applications having user authentication in the TLS layer may be the simplest way to get user authentication into the application.</li>
</ul>
<h3 class="subsection"><span class="subsection_label">3.4</span> <a id='magicparlabel-329' />
Party Responsible for Infrastructure Messaging</h3>
<div class="revisionremark"><a id='magicparlabel-330' />
XXX Add references for OCSP, AAA, ...</div>

<div class="standard"><a id='magicparlabel-331' />
&ldquo;Infrastructure&rdquo; consists, for the purposes of this document, of services such as Identity Providers (IdPs), Certificate Revocation Lists (CRLs) and their servers, Online Certificate Status Protocol (OCSP) responders, Kerberos Key Distribution Centers (KDCs), RADIUS/DIAMETER servers, etcetera. These are services that run on parties other than a client (e.g., a web browser / user agent) and an application server. In some cases infrastructure services may be physically co-located with the client or server, but by and large they are physically separated; infrastructure services are always logically separate from the client and server.</div>

<div class="standard"><a id='magicparlabel-332' />
Some protocols require that the client do all or most of the message exchanges with infrastructure, some require that the server do this messaging, some require both to do some messaging. In some cases a server might proxy a client's messages to infrastructure. There are advantages to the client doing this messaging: namely a simpler server, less subject to denial of service . resource consumption attacks. [Are there advantages to the server doing this messaging?]</div>

<div class="standard"><a id='magicparlabel-333' />
Consider a protocol like Kerberos. Kerberos relies on Key Distribution Center (KDC) infrastructure, and it relies on the client doing all the messaging needed to ultimately authenticate it to a server. Kerberos can be used in a way such that the relying party proxies this messaging for the client (see IAKERB), but even so the client had to communicate with the KDCs in order to ultimately authenticate to the relying party &ndash; IAKERB is simply a proxy mechanism.</div>

<div class="standard"><a id='magicparlabel-334' />
Now consider an authentication mechanism based on PKI. The only online infrastructure in a PKI are the CRLs and OCSP responders. Of course, a Certificate Authority (CA) can also be online, as in kca [add reference], a CA that authenticates clients via Kerberos and which issues fresh, short-lived certificates. Private keys for certificates can also be served by online services such as SACRED and browserid. The method of validating certificates currently considered ideal is for the possessor of certificate's private key to send both, the certificate and a current/fresh OCSP response for it (or, rather, responses, for the entire certificate chain), thus the PKI relying party should ideally not have to contact infrastructure; in practice CRL checking is still the more commonly used method, requiring infrastructure messaging on the relying party side.</div>

<div class="standard"><a id='magicparlabel-335' />
The responsibility for infrastructure messaging varies widely.</div>
<h3 class="subsection"><span class="subsection_label">3.5</span> <a id='magicparlabel-336' />
Number of Messages</h3>
<div class="standard"><a id='magicparlabel-337' />
The number of messages that must be exchanged in order to authenticate a peer varies a lot by authentication mechanism. Some require just one message from the client to the server. Others require a reply message from the server. Others require some larger number of messages (typically three or four). Yet others require a variable number of messages.</div>

<div class="standard"><a id='magicparlabel-338' />
Typically key exchange is also required in order to provide confidentiality and integrity protection to the transport. Key exchange protocols also vary in number of messages required. Key exchange and authentication may be combined, either directly in a single network layer, or across layers via channel binding.</div>

<div class="standard"><a id='magicparlabel-339' />
One-message authentication protocols:</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-340' />
OAuth</li>
<li class="itemize_item"><a id='magicparlabel-341' />
Kerberos (w/o key confirmation)</li>
<li class="itemize_item"><a id='magicparlabel-342' />
Public key signature schemes when authenticating only the client</li>
<li class="itemize_item"><a id='magicparlabel-343' />
Diffie-Hellman (when the client knows the server's DH public key a priori, and w/o key confirmation)</li>
<li class="itemize_item"><a id='magicparlabel-344' />
RSA key transport (w/o key confirmation)</li>
<li class="itemize_item"><a id='magicparlabel-345' />
all bearer token protocols (but see [ref to on channel bindings section])</li>
</ul>
<div class="standard"><a id='magicparlabel-346' />
Two-message authentication protocols:</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-347' />
Kerberos</li>
<li class="itemize_item"><a id='magicparlabel-348' />
Diffie-Hellman with fixed public keys</li>
<li class="itemize_item"><a id='magicparlabel-349' />
RSA key transport</li>
</ul>
<div class="standard"><a id='magicparlabel-350' />
Authentication protocols with three or more messages, or with arbitrary numbers of messages:</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-351' />
Most/all zero-knowledge password proof protocols (e.g., SRP) (usually three or four messages)</li>
<li class="itemize_item"><a id='magicparlabel-352' />
SCRAM, and other challenge-response protocols (usually three or four messages)</li>
<li class="itemize_item"><a id='magicparlabel-353' />
IAKERB (usually four messages)</li>
<li class="itemize_item"><a id='magicparlabel-354' />
Pluggable frameworks (SASL, GSS, EAP) (arbitrary message counts, usually dependent on what mechanism is selected)</li>
</ul>
<div class="standard"><a id='magicparlabel-355' />
It's worth pointing out that TLS is a three- or four-message protocol, but when providing confidentiality protection for the client identity it becomes a six- to eight-message protocol (though there is a proposal to improve this, getting back to three to four messages [add reference to Marsh's I-D]).</div>

<div class="standard"><a id='magicparlabel-356' />
Some authentication protocols can provide key exchange, others cannot. Similarly, not all mechanisms can provide channel binding.</div>

<div class="standard"><a id='magicparlabel-357' />
The total number of messages required is important. These message exchanges are always ordered and synchronous; no progress can be made by the application until they are completed. Over long distances the time to complete each round trip add up to noticeable latency, and there is much pressure to get this latency down to an absolute minimum.</div>

<div class="standard"><a id='magicparlabel-358' />
Integrating user authentication into TLS has the clear allure of potentially cutting down the number of round trips necessary, but it's not clear that this can be achieved in every case. In particular it may not be clear that a client has to authenticate until after a TLS connection is established over which the client may request access to some resource that requires authenticated clients.</div>
<h3 class="subsection"><span class="subsection_label">3.6</span> <a id='magicparlabel-359' />
Trust Establishment</h3>
<div class="standard"><a id='magicparlabel-360' />
Pair-wise pre-shared keying systems require careful initial key exchange, but otherwise have no transitive trust issues: every pair of entities that has shared keying can communicate without the aid of any other entity. However, pair-wise pre-shared keying does not scale to the Internet as it is O(n^2).</div>

<div class="standard"><a id='magicparlabel-361' />
Authentication mechanisms that scale to the Internet of necessity require some degree of trust transitivity. That is, there must be many cases where Alice and Bob can communicate with each other only because they can authenticate each other by way of one or more third parties (e.g., Trent) that each of them trust a priori.</div>

<div class="standard"><a id='magicparlabel-362' />
There are a number of issues with trust transitivity:</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-363' />
Trusted third parties can mount MITM attacks on the parties that trust them</li>
<li class="itemize_item"><a id='magicparlabel-364' />
Compromise of trusted third parties has far reaching, negative effects</li>
<li class="itemize_item"><a id='magicparlabel-365' />
Policy for trust transit paths is difficult to express</li>
<li class="itemize_item"><a id='magicparlabel-366' />
Mechanisms for establishing trust paths are often manual and prone to error or abuse</li>
</ul>
<div class="standard"><a id='magicparlabel-367' />
There are several ways to use transitive trust. In hierarchical transitive trust we organize the trusted third parties in such a way that there should be a trust path for every pair of entities of interest (e.g., every user to every server, every user to every user, ...) &ndash; think of PKI. In mesh systems trust transits through every entity's &ldquo;friends&rdquo; &ndash; think of PGP.</div>

<div class="standard"><a id='magicparlabel-368' />
There may be other models of transitive trust, such as one with islands of trust. An islands of trust model would consist of federations of transitive trust (using hierarchical or mesh models) that are much smaller than the entire Internet, but large enough to be of use to large numbers of users. For example, an online merchant might provide for authentication of all users to a set of participating vendors[Expand on this greatly!!]</div>

<div class="standard"><a id='magicparlabel-369' />
Given the need for transitive trust and the serious drawbacks of transitive trust, some workarounds may be necessary, such as:</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-370' />
Policy language for choosing suitable trust paths</li>
<li class="itemize_item"><a id='magicparlabel-371' />
Facilities for limiting the length of, or otherwise shortening trust paths</li>
<li class="itemize_item"><a id='magicparlabel-372' />
&ldquo;Pinning&rdquo; facilities to force changes in the infrastructure to proceed in ways which make some MITM attacks harder to mount</li>
<li class="itemize_item"><a id='magicparlabel-373' />
Auditing facilities by which to show that trusted third parties are not mounting MITM attacks</li>
<li class="itemize_item"><a id='magicparlabel-374' />
Revocation facilities that actually work</li>
<li class="itemize_item"><a id='magicparlabel-375' />
Root keys that are rarely used and live in HSMs?</li>
<li class="itemize_item"><a id='magicparlabel-376' />
Fast re-keying?</li>
</ul>
<div class="standard"><a id='magicparlabel-377' />
For an example of pinning, consider a TLS extension where self-signed, persistent user certificates are used, possibly one per-origin for pseudonymity purposes. The user agent can enroll the user certificates at their corresponding origin servers such that thereafter no MITMs are possible that can impersonate the user to the server. Of course, such a scheme suffers from needing a fall-back authentication method when the user's device(s) that store the relevant private keys are lost. Users would need to be able to fall-back on an alternative authentication method for re-enrollment, likely one that is susceptible to attack or else is inconvenient. In this cases the pinning is on the server side; keep in mind that pinning need not only be used on clients, but may be used even in the distributed trust infrastructure (e.g., to shorten trust paths).</div>

<div class="standard"><a id='magicparlabel-378' />
Ideally an authentication facility for HTTP/2.0 should support a variety of trust establishment models, as it is not clear that one mode is superior to the others. (Though certainly the hierarchical model is the most scalable in a single-sign-on (SSO) manner. However, users may not mind having a small number of logon credentials for a trust island model.)</div>
<h3 class="subsection"><span class="subsection_label">3.7</span> <a id='magicparlabel-379' />
Threat Modeling</h3>
<div class="standard"><a id='magicparlabel-380' />
[Cover the Internet threat model. Discuss the end-to-end model and the hop-by-hop semantics of transitive trust.]</div>
<h3 class="subsection"><span class="subsection_label">3.8</span> <a id='magicparlabel-381' />
Explicit versus Implisit Session Management</h3>
<div class="standard"><a id='magicparlabel-382' />
[Discuss lack of / weakness of application session concept on the web. Discuss the historically limited application of TLS sessions to HTTP apps. Discuss desirability of a real concept of session and logout.]</div>
<h3 class="subsection"><span class="subsection_label">3.9</span> <a id='magicparlabel-383' />
In-Band versus Out-of-Band Authentication</h3>
<div class="standard"><a id='magicparlabel-384' />
[Discuss out-of-band user authentication systems such as ones where &ldquo;tokens&rdquo; are sent to users' mobile phones via SMS, as well as systems where a &ldquo;login URL&rdquo; is sent to the user via e-mail.]</div>
<h2 class="section"><span class="section_label">4</span> <a id='magicparlabel-385' />
Analysis of Some Possible Authentication Proposals</h2>
<div class="standard"><a id='magicparlabel-386' />
[Cover:</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-387' />
Authentication mechanisms:

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-388' />
Bearer token systems</li>
<li class="itemize_item"><a id='magicparlabel-389' />
Other half round trip systems, including Kerberos, OAuth</li>
<li class="itemize_item"><a id='magicparlabel-390' />
PK w/ SACRED, browserid, smartcards</li>
<li class="itemize_item"><a id='magicparlabel-391' />
ZKPPs</li>
<li class="itemize_item"><a id='magicparlabel-392' />
Challenge/response password-based mechanisms (DIGEST-MD5, SCRAM)</li>
</ul>
</li><li class="itemize_item"><a id='magicparlabel-393' />
Generic auth frameworks

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-394' />
GSS, SASL, EAP (anything else? IKEv2? SSHv2?)</li>
</ul>
</li><li class="itemize_item"><a id='magicparlabel-395' />
Authentication in TLS, HTTP, and above HTTP</li>
<li class="itemize_item"><a id='magicparlabel-396' />
OTP and out-of-band (SMS, e-mail) auth, both as part of authentication mechanisms and as port of traditional webauth.</li>
<li class="itemize_item"><a id='magicparlabel-397' />
Traditional webauth (passwords posted in forms), possibly with password wallets (stateful and stateless)</li>
</ul>
<div class="standard"><a id='magicparlabel-398' />
]</div>

<div class="revisionremark"><a id='magicparlabel-399' />
What else to cover?</div>
<h2 class="section"><span class="section_label">5</span> <a id='magicparlabel-400' />
Author's Recommendations</h2>
<div class="standard"><a id='magicparlabel-401' />
It seems likely that no single user authentication method will satisfy the needs of all web applications. Nor can we predict the future. This argues for a multitude of solutions, and possibly a pluggable system. The author proposes the following:</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-402' />
For all authentication mechanisms (i.e., cryptographic authentication methods) use the GSS-API, possibly through the thin shim of RFC5801 [XXX change into reference].

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-403' />
do this above HTTP in the network stack, but...</li>
<li class="enumerate_item"><a id='magicparlabel-404' />
...recommend that this be implemented by HTTP stacks, rather than by applications. I.e., authentication above HTTP on the wire, within HTTP as far as APIs are concerned.</li>
</ol>
</li><li class="enumerate_item"><a id='magicparlabel-405' />
Encourage development of authentication mechanisms that fit the chosen authentication framework and which have the following features:

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-406' />
federation (which implies trusted third parties)</li>
<li class="enumerate_item"><a id='magicparlabel-407' />
strong initial user authentication (e.g., with ZKPPs)</li>
<li class="enumerate_item"><a id='magicparlabel-408' />
minimized password verifier attack surface area (e.g., minize the number of servers that have access to password verifiers)</li>
<li class="enumerate_item"><a id='magicparlabel-409' />
trust path bootstrapping</li>
<li class="enumerate_item"><a id='magicparlabel-410' />
short trust paths</li>
<li class="enumerate_item"><a id='magicparlabel-411' />
auditable trusted third parties</li>
<li class="enumerate_item"><a id='magicparlabel-412' />
[preferably] mutual authentication</li>
</ol>
</li><li class="enumerate_item"><a id='magicparlabel-413' />
Specify a new URI scheme that identifies services rather than hosts. For example: svc:&lt;service&gt;@&lt;domainname&gt;/&lt;local-part&gt; . An option to embed service authentication information (possibly a digital signature, or a URL referring to a digital signature) may prove useful.

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-414' />
Also specify a service location protocol.</li>
</ol>
</li><li class="enumerate_item"><a id='magicparlabel-415' />
Specify an abstract API for interfacing HTTPbis applications to HTTPbis.</li>
</ol>
<h2 class="section"><span class="section_label">6</span> <a id='magicparlabel-416' />
References</h2>
<div class="bibliography"><a id='magicparlabel-417' />
<a id='' />
<span class='bibitemlabel'>1</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-421' />
rfc2119</div>
</div><a href="http://www.ietf.org/rfc/rfc2119.txt">RFC2119</a><a href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-422' />
<a id='' />
<span class='bibitemlabel'>2</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-426' />
rfc5246</div>
</div><a href="http://www.ietf.org/rfc/rfc5246.txt">RFC5246</a><a href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-427' />
<a id='' />
<span class='bibitemlabel'>3</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-431' />
rfc2616</div>
</div><a href="http://www.ietf.org/rfc/rfc2616.txt">RFC2616</a><a href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-432' />
<a id='' />
<span class='bibitemlabel'>4</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-436' />
rfc5056</div>
</div><a href="http://www.ietf.org/rfc/rfc5056.txt">RFC5056</a><a href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5056.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-437' />
<a id='' />
<span class='bibitemlabel'>5</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-441' />
rfc4120</div>
</div><a href="http://www.ietf.org/rfc/rfc4120.txt">RFC4120</a><a href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4120.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-442' />
<a id='' />
<span class='bibitemlabel'>6</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-446' />
I-D.williams-rest-gss</div>
</div><a href="https://datatracker.ietf.org/doc/draft-williams-rest-gss/">I-D.williams-rest-gss</a><a href="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.williams-rest-gss.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-447' />
<a id='' />
<span class='bibitemlabel'>7</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-451' />
I-D.hartman-webauth-phishing</div>
</div><a href="https://datatracker.ietf.org/doc/draft-hartman-webauth-phishing/">I-D.hartman-webauth-phishing</a><a href="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.hartman-webauth-phishing.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-452' />
<a id='' />
<span class='bibitemlabel'>8</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-456' />
rfc2818</div>
</div><a href="http://www.ietf.org/rfc/rfc2818.txt">RFC2818</a><a href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-457' />
<a id='' />
<span class='bibitemlabel'>9</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-461' />
rfc4422</div>
</div><a href="http://www.ietf.org/rfc/rfc4422.txt">RFC4422</a><a href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4422.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-462' />
<a id='' />
<span class='bibitemlabel'>10</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-466' />
rfc5802</div>
</div><a href="http://www.ietf.org/rfc/rfc5802.txt">RFC5802</a><a href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5802.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-467' />
<a id='' />
<span class='bibitemlabel'>11</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-471' />
rfc2617</div>
</div><a href="http://www.ietf.org/rfc/rfc2617.txt">RFC2617</a><a href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-472' />
<a id='' />
<span class='bibitemlabel'>12</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-476' />
rfc3748</div>
</div><a href="http://www.ietf.org/rfc/rfc3748.txt">RFC3748</a><a href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3748.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-477' />
<a id='' />
<span class='bibitemlabel'>13</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-481' />
rfc2743</div>
</div><a href="http://www.ietf.org/rfc/rfc2743.txt">RFC2743</a><a href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2743.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-482' />
<a id='' />
<span class='bibitemlabel'>14</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-486' />
rfc4559</div>
</div><a href="http://www.ietf.org/rfc/rfc4559.txt">RFC4559</a><a href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4559.xml">(bibxml)</a></div>

<div class="bibliography"><a id='magicparlabel-487' />
<a id='' />
<span class='bibitemlabel'>15</span><div class="flex_referenceentity"><div class="plain_layout"><a id='magicparlabel-491' />
rfc4121</div>
</div><a href="http://www.ietf.org/rfc/rfc4121.txt">RFC4121</a><a href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4121.xml">(bibxml)</a></div>

<div class="standard"><a id='magicparlabel-492' />
[Add references for HSTS, SACRED, OAuth, browserid, OpenId, and many others.]</div>

<div class="standard"><a id='magicparlabel-493' />
[Re-order the references into a saner order, with HTTP and TLS first, then auth frameworks, then auth mechanisms, then ...; I-Ds last. Or maybe sort fir RFCs first, in numeric order, then I-Ds in alphabetic order. Either way, a saner ordering.]</div>
</body>
</html>
