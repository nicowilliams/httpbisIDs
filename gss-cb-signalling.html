<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en"><head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/"><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>Channel Binding Signalling for the Generic Security Services Application Programming Interface</title><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: verdana, helvetica, arial, sans-serif;
  font-size: 10pt;
  margin-right: 2em;
}
cite {
  font-style: normal;
}
dl {
  margin-left: 2em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 14pt;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h1 a {
  color: #333333;
}
h2 {
  font-size: 12pt;
  line-height: 15pt;
  page-break-after: avoid;
}
h3, h4, h5, h6 {
  font-size: 10pt;
  page-break-after: avoid;
}
h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
}
ol {
  margin-left: 2em;
}
ol.la {
  list-style-type: lower-alpha;
}
ol.ua {
  list-style-type: upper-alpha;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
  page-break-inside: avoid;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
table {
  margin-left: 2em;
}
table.header {
  border-spacing: 1px;
  width: 95%;
  font-size: 10pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap; 
}
table.header td {
  background-color: gray;
  width: 50%;
}
table.header a {
  color: white;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc, ul.toc ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
}
ul.toc li {
  line-height: 150%;
  font-weight: bold;
  font-size: 10pt;
  margin-left: 0em;
}
ul.toc li li {
  line-height: normal;
  font-weight: normal;
  font-size: 9pt;
  margin-left: 0em;
}
li.excluded {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}

.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 9pt;
}
.filename {
  color: #333333;
  font-weight: bold;
  font-size: 12pt;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.hidden {
  display: none;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: #990000;
  font-size: 18pt;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.vcardline {
  display: block;
}
.warning {
  font-size: 14pt;
  background-color: yellow;
}


@media print {
  .noprint {
    display: none;
  }
  
  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 12pt;
  }

  ul.toc a::after {
    content: leader('.') target-counter(attr(href), page);
  }
  
  ul.ind li li a {
    content: target-counter(attr(href), page);
  }
  
  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "Internet-Draft"; 
  } 
  @top-right {
       content: "February 2013"; 
  } 
  @top-center {
       content: "GSS Channel Bound Flag"; 
  } 
  @bottom-left {
       content: "Williams"; 
  } 
  @bottom-center {
       content: "Expires August 31, 2013"; 
  } 
  @bottom-right {
       content: "[Page " counter(page) "]"; 
  } 
}

@page:first { 
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Channel Binding State Extension" href="#rfc.section.2"><link rel="Chapter" title="3 Modified Channel Binding Semantics" href="#rfc.section.3"><link rel="Chapter" title="4 Security Considerations" href="#rfc.section.4"><link rel="Chapter" title="5 IANA Considerations" href="#rfc.section.5"><link rel="Chapter" href="#rfc.section.6" title="6 References"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.580, 2012-06-03 11:18:18, XSLT vendor: SAXON 9.0.0.4 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dct" href="http://purl.org/dc/terms/"><meta name="dct.creator" content="Williams, N."><meta name="dct.identifier" content="urn:ietf:id:draft-williams-kitten-channel-bound-flag-03"><meta name="dct.issued" scheme="ISO8601" content="2013-02-27"><meta name="dct.abstract" content="Channel binding is a technique that allows applications to use a secure channel at a lower layer without having to use authentication at that lower layer. The concept of channel binding comes from the Generic Security Services Application Programming Interface (GSS-API). It turns out that the semantics implemented are different that those specified in RFC2743, and the specification has a serious bug. This document addresses both, the inconsistency as-implemented and the specification bug. This Internet-Draft proposes the addition of a &#8220;channel bound&#8221; return flag for the GSS_Init_sec_context() and GSS_Accept_sec_context() functions. Two behaviors are specified: a default, safe behavior reflecting existing implementation deployments, and a behavior that is only safe when the application specifically tells the GSS-API that it (the application) supports the new behavior. Additional API elements related to this are also added."><meta name="description" content="Channel binding is a technique that allows applications to use a secure channel at a lower layer without having to use authentication at that lower layer. The concept of channel binding comes from the Generic Security Services Application Programming Interface (GSS-API). It turns out that the semantics implemented are different that those specified in RFC2743, and the specification has a serious bug. This document addresses both, the inconsistency as-implemented and the specification bug. This Internet-Draft proposes the addition of a &#8220;channel bound&#8221; return flag for the GSS_Init_sec_context() and GSS_Accept_sec_context() functions. Two behaviors are specified: a default, safe behavior reflecting existing implementation deployments, and a behavior that is only safe when the application specifically tells the GSS-API that it (the application) supports the new behavior. Additional API elements related to this are also added."></head><body><table class="header"><tbody><tr><td class="left">Network Working Group</td><td class="right">N. Williams</td></tr><tr><td class="left">Internet-Draft</td><td class="right">Cryptonector</td></tr><tr><td class="left">Updates: RFC2743 RFC2744 (if approved)</td><td class="right">February 27, 2013</td></tr><tr><td class="left">Intended status: Standards Track</td><td class="right"></td></tr><tr><td class="left">Expires: August 31, 2013</td><td class="right"></td></tr></tbody></table><p class="title">Channel Binding Signalling for the Generic Security Services Application Programming Interface<br><span class="filename">draft-williams-kitten-channel-bound-flag-03</span></p><h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1><p>Channel binding is a technique that allows applications to use a secure channel at a lower layer without having to use authentication at that lower layer. The concept of channel binding comes from the Generic Security Services Application Programming Interface (GSS-API). It turns out that the semantics implemented are different that those specified in RFC2743, and the specification has a serious bug. This document addresses both, the inconsistency as-implemented and the specification bug.</p><p>This Internet-Draft proposes the addition of a &#8220;channel bound&#8221; return flag for the GSS_Init_sec_context() and GSS_Accept_sec_context() functions. Two behaviors are specified: a default, safe behavior reflecting existing implementation deployments, and a behavior that is only safe when the application specifically tells the GSS-API that it (the application) supports the new behavior. Additional API elements related to this are also added.</p><h1><a id="rfc.status" href="#rfc.status">Status of this Memo</a></h1><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as &#8220;work in progress&#8221;.</p><p>This Internet-Draft will expire on August 31, 2013.</p><h1><a id="rfc.copyrightnotice" href="#rfc.copyrightnotice">Copyright Notice</a></h1><p>Copyright © 2013 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p><hr class="noprint"><h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1><ul class="toc"><li>1.&nbsp;&nbsp;&nbsp;<a href="#d1e279">Introduction</a><ul><li>1.1&nbsp;&nbsp;&nbsp;<a href="#d1e319">Error in RFC2743</a></li><li>1.2&nbsp;&nbsp;&nbsp;<a href="#d1e334">Design</a></li><li>1.3&nbsp;&nbsp;&nbsp;<a href="#d1e358">Alternative Design</a></li><li>1.4&nbsp;&nbsp;&nbsp;<a href="#d1e367">Future Directions</a></li><li>1.5&nbsp;&nbsp;&nbsp;<a href="#d1e386">Conventions used in this document</a></li></ul></li><li>2.&nbsp;&nbsp;&nbsp;<a href="#d1e401">Channel Binding State Extension</a><ul><li>2.1&nbsp;&nbsp;&nbsp;<a href="#d1e428">GSS_Create_sec_context()</a><ul><li>2.1.1&nbsp;&nbsp;&nbsp;<a href="#d1e471">C-Bindings</a></li></ul></li><li>2.2&nbsp;&nbsp;&nbsp;<a href="#d1e483">GSS_Set_context_flags()</a><ul><li>2.2.1&nbsp;&nbsp;&nbsp;<a href="#d1e541">C-Bindings</a></li></ul></li><li>2.3&nbsp;&nbsp;&nbsp;<a href="#d1e553">Return Flag for Channel Binding State Signalling</a><ul><li>2.3.1&nbsp;&nbsp;&nbsp;<a href="#d1e562">C-Bindings</a></li></ul></li><li>2.4&nbsp;&nbsp;&nbsp;<a href="#d1e575">New Mechanism Attributes</a></li><li>2.5&nbsp;&nbsp;&nbsp;<a href="#d1e591">Request Flag for Acceptor Confirmation of Channel Binding</a><ul><li>2.5.1&nbsp;&nbsp;&nbsp;<a href="#d1e606">C-Bindings</a></li></ul></li></ul></li><li>3.&nbsp;&nbsp;&nbsp;<a href="#d1e622">Modified Channel Binding Semantics</a></li><li>4.&nbsp;&nbsp;&nbsp;<a href="#d1e644">Security Considerations</a></li><li>5.&nbsp;&nbsp;&nbsp;<a href="#d1e665">IANA Considerations</a></li><li>6.&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li>6.1&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li>6.2&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.authors">Author's Address</a></li></ul><hr class="noprint"><h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a id="d1e279" href="#d1e279">Introduction</a></h1><p id="rfc.section.1.p.1">The GSS-API <a href="#RFC2743"><cite title="Generic Security Service Application Program Interface Version 2, Update 1">[RFC2743]</cite></a> supports &#8220;channel binding&#8221; <a href="#RFC5056"><cite title="On the Use of Channel Bindings to Secure Channels">[RFC5056]</cite></a>, a technique for detection of man-in-the-middle (MITM) attacks in secure channels at lower network layers. This facility is meant to be all-or-nothing: either both the initiator and acceptor use it and it succeeds, or both must not use it. This has created a negotiation problem when retrofitting the use of channel binding into existing application protocols.</p><p id="rfc.section.1.p.2">Many implementations of the Kerberos V5 GSS-API mechanism <a href="#RFC4121"><cite title="The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2">[RFC4121]</cite></a> cause the acceptor to succeed when the initiator used channel binding but the acceptor application did not. This has helped deployment of channel binding in existing applications: first fix all the initiators, then fix all the acceptors. But even this is insufficient when there are many clients to fix, such that fixing them all will take a long time.</p><p id="rfc.section.1.p.3">This document proposes a new method for deployment of channel binding that allows the feature to be enabled on the acceptor side before fixing all initiators. If the GSS-API had always had a return flag by which to indicate channel binding state then we could have had a simpler method of deploying channel binding: applications check that return flag and act accordingly (e.g., fail when channel binding is required). We cannot safely introduce this behavior now without an indication of support by the application.</p><p id="rfc.section.1.p.4">It is worth noting that at least one implementor of GSS-API mechanisms (but not of the GSS-API itself) has similar semantics in its API to those proposed herein. [XXX add references to the relevant SSPI docs? -Nico]</p><p id="rfc.section.1.p.5">Additionally, there may be applications where it is important for initiators to know that acceptors did use channel binding, and even to know whether a mechanism is capable of indicating as much. We add a request flag and two mechanism attributes for such applications.</p><h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a id="d1e319" href="#d1e319">Error in RFC2743</a></h2><p id="rfc.section.1.1.p.1">The GSS-APIv2u1 <a href="#RFC2743"><cite title="Generic Security Service Application Program Interface Version 2, Update 1">[RFC2743]</cite></a> seems to indicate that mechanisms must ignore channel bindings when one party provided none. In practice some mechanisms ignore channel bindings when the acceptor provides none, but not when the initiator provides none. Note that it would be useless to allow security context establishment to succeed when the initiator does not provide channel bindings but the acceptor does, at least as long as there's no outward indication of whether channel binding was used! And indeed, the GSS-APIv2u1 does not provide any such indication. We correct this flaw in this document.</p><h2 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2</a>&nbsp;<a id="d1e334" href="#d1e334">Design</a></h2><p id="rfc.section.1.2.p.1">After some discussion on the mailing list of various designs for signalling application support for the new flag we've settled on copying an aspect of the Java Bindings of the GSS-API <a href="#RFC5653"><cite title="Generic Security Service API Version 2: Java Bindings Update">[RFC5653]</cite></a>, specifically the notion of creating an &#8220;empty&#8221; SECURITY CONTEXT handle that can then be passed to GSS_Init_sec_context() and GSS_Accept_sec_context() where they normally expect a NULL handle. This empty security context handle can then be used to set options relating to security context token establishment.</p><p id="rfc.section.1.2.p.2">In <a href="#I-D.williams-williams-kitten-ctx-simple-async"><cite title="Simplified and Asynchronous Security Context Interfaces for the Generic Security Services Application Programming Interface">[I-D.williams-williams-kitten-ctx-simple-async]</cite></a> we explore and extend this design to produce a more usable GSS-API (as well as support for asynchronous operation).</p><h2 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3</a>&nbsp;<a id="d1e358" href="#d1e358">Alternative Design</a></h2><p id="rfc.section.1.3.p.1">The previous design was based on an existing, non-standard extension for carrying security context establishment options in CREDENTIAL HANDLEs. Note that a notion of CREDENTIAL HANDLE options might still be useful for options that are really specific to credentials rather than security context tokens (for example: setting an acceptable cryptographic security profile on a CREDENTIAL HANDLE and receiving a new handle with possibly fewer elements, reflecting that some credentials cannot meet the requirement).</p><h2 id="rfc.section.1.4"><a href="#rfc.section.1.4">1.4</a>&nbsp;<a id="d1e367" href="#d1e367">Future Directions</a></h2><p id="rfc.section.1.4.p.1">We're likely to introduce additional mutator functions of empty contexts, with mutators corresponding to many of the existing input arguments of GSS_Init_sec_context() and GSS_Accept_sec_context(), as well as a few additional security context inquiry functions. We're also likely to then introduce new variants of GSS_Init_sec_context() and GSS_Accept_sec_context() with all of those input and output parameters removed that could be set or retrieved with the other new functions. The only inputs that the new GSS_Init/Accept_sec_context() must have are: a security context handle (never NULL), and an input context token, and the only outputs should be the status indicators and an output token -- in fact, we may want to have just one new function called, perhaps, GSS_Step_sec_context(), with the role of initiator or acceptor set as a context option.</p><p id="rfc.section.1.4.p.2">See <a href="#I-D.williams-williams-kitten-ctx-simple-async"><cite title="Simplified and Asynchronous Security Context Interfaces for the Generic Security Services Application Programming Interface">[I-D.williams-williams-kitten-ctx-simple-async]</cite></a>.</p><h2 id="rfc.section.1.5"><a href="#rfc.section.1.5">1.5</a>&nbsp;<a id="d1e386" href="#d1e386">Conventions used in this document</a></h2><p id="rfc.section.1.5.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p><hr class="noprint"><h1 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a id="d1e401" href="#d1e401">Channel Binding State Extension</a></h1><p id="rfc.section.2.p.1">We propose a new return flag for GSS_Init_sec_context() and GSS_Accept_sec_context(), as well as a pair of functions for a) creating &#8220;empty&#8221; security context handles, b) setting req_flags and indicating which ret_flags the application understands. We also add new mechanism attributes describing mechanism capabilities.</p><p id="rfc.section.2.p.2">C bindings of these extensions are provided along the lines of <a href="#RFC2744"><cite title="Generic Security Service API Version 2 : C-bindings">[RFC2744]</cite></a> and <a href="#RFC5587"><cite title="Extended Generic Security Service Mechanism Inquiry APIs">[RFC5587]</cite></a>.</p><p id="rfc.section.2.p.3">In the future we might move more of the many input (and output) arguments to GSS_Init_sec_context() and GSS_Accept_sec_context() into mutators on empty security context handles.</p><h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a id="d1e428" href="#d1e428">GSS_Create_sec_context()</a></h2><p id="rfc.section.2.1.p.1">Inputs:</p><p id="rfc.section.2.1.p.2"> </p><ul><li>&lt;none&gt;</li></ul><p id="rfc.section.2.1.p.3">Outputs:</p><p id="rfc.section.2.1.p.4"> </p><ul><li>major_status INTEGER</li><li>minor_status INTEGER -- note: mostly useless, but we should keep it</li><li>context SECURITY CONTEXT</li></ul><p id="rfc.section.2.1.p.5">Return major status codes:</p><p id="rfc.section.2.1.p.6"> </p><ul><li>GSS_S_COMPLETE indicates success.</li><li>GSS_S_UNAVAILABLE indicates that memory is not available, for example.</li><li>GSS_S_FAILURE indicates a general failure.</li></ul><p id="rfc.section.2.1.p.7">This function creates an &#8220;empty&#8221; security context handle that can be passed to GSS_Init_sec_context() or GSS_Accept_sec_context() where they expect a NULL context.</p><h3 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1</a>&nbsp;<a id="d1e471" href="#d1e471">C-Bindings</a></h3><p id="rfc.section.2.1.1.p.2"> </p><div id="rfc.figure.u.1"></div><pre> OM_uint32
 gss_create_sec_context(OM_uint32 *minor_status,
                        gss_ctx_id_t *context);</pre><h2 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a id="d1e483" href="#d1e483">GSS_Set_context_flags()</a></h2><p id="rfc.section.2.2.p.1">Inputs:</p><p id="rfc.section.2.2.p.2"> </p><dl><dt>context&nbsp;CONTEXT&nbsp;HANDLE</dt><dt>req_flags&nbsp;FLAGS</dt><dd>Requested flags. Applicable to acceptors and initiators.</dd><dt>ret_flags_understood&nbsp;FLAGS</dt><dd>The set of return flags understood by the caller.</dd></dl><p id="rfc.section.2.2.p.3">Outputs:</p><p id="rfc.section.2.2.p.4"> </p><ul><li>major_status INTEGER</li><li>minor_status INTEGER</li></ul><p id="rfc.section.2.2.p.5">Return major status codes:</p><p id="rfc.section.2.2.p.6"> </p><ul><li>GSS_S_COMPLETE indicates success.</li><li>GSS_S_FAILURE indicates a general failure.</li></ul><p id="rfc.section.2.2.p.7">This function tells the mechanism (when one is eventually chosen and invoked) that the application requests the given req_flags and undestands the given ret_flags. Initiators can override the req_flags in their GSS_Init_sec_context() call, but if no flags are requested there then the req_flags set on the empty context will be used.</p><p id="rfc.section.2.2.p.8">NOTE: The abstract GSS-API <a href="#RFC2743"><cite title="Generic Security Service Application Program Interface Version 2, Update 1">[RFC2743]</cite></a> uses individual elements -one per-flag- instead of a &#8220;FLAGS&#8221; type. This is unwieldy, therefore we introduce an abstract type named &#8220;FLAGS&#8221; to act as a set of all the request/return flags defined for the abstract GSS-API.</p><h3 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1</a>&nbsp;<a id="d1e541" href="#d1e541">C-Bindings</a></h3><p id="rfc.section.2.2.1.p.2"> </p><div id="rfc.figure.u.2"></div><pre> OM_uint32
 gss_set_context_flags(OM_uint32 *minor_status,
                       gss_ctx_id_t context,
                       uint64_t req_flags,
                       uint64_t ret_flags);</pre><h2 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3</a>&nbsp;<a id="d1e553" href="#d1e553">Return Flag for Channel Binding State Signalling</a></h2><p id="rfc.section.2.3.p.1">Whenever both the initiator and the acceptor provide matching channel bindings to GSS_Init_sec_context() and GSS_Accept_sec_context(), respectively, then the mechanism SHALL indicate that the context is channel bound via an output flag, ret_channel_bound_flag, for the established context. Note that some mechanisms have no way for the acceptor to signal CB success to the initiator, in which case GSS_Init_sec_context() MUST NOT output the ret_channel_bound_flag.</p><h3 id="rfc.section.2.3.1"><a href="#rfc.section.2.3.1">2.3.1</a>&nbsp;<a id="d1e562" href="#d1e562">C-Bindings</a></h3><p id="rfc.section.2.3.1.p.2"> </p><div id="rfc.figure.u.3"></div><pre> #define GSS_C_CHANNEL_BOUND_FLAG 2048 /* 0x00000800 */</pre><h2 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4</a>&nbsp;<a id="d1e575" href="#d1e575">New Mechanism Attributes</a></h2><p id="rfc.section.2.4.p.1"> </p><ul><li>We add a new mechanism attribute, GSS_C_MA_CBINDING_CONFIRM, to indicate that the initiator can and always does learn whether the acceptor application supplied channel bindings.</li><li>We add a new mechanism attribute, GSS_C_MA_CBINDING_MAY_CONFIRM, to indicate that the initiator may learn whether the acceptor application supplied channel bindings, but only when the acceptor implementation of the mechanism has been suitably updated.</li></ul><p id="rfc.section.2.4.p.2">OID assignments TBD.</p><h2 id="rfc.section.2.5"><a href="#rfc.section.2.5">2.5</a>&nbsp;<a id="d1e591" href="#d1e591">Request Flag for Acceptor Confirmation of Channel Binding</a></h2><p id="rfc.section.2.5.p.1">We add a new request flag for GSS_Init_sec_context(), req_cb_confirmation_flag, to be used by initiators that insist on acceptors providing channel bindings. This flag is only of use to mechanism-negotiation pseudo-mechanisms (e.g., SPNEGO <a href="#RFC4178"><cite title="The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism">[RFC4178]</cite></a>): if set the pseudo-mechanism MUST NOT negotiate any mechanisms that lack the GSS_C_MA_CBINDING_CONFIRM or GSS_C_MA_CBINDING_MAY_CONFIRM mechanism attributes, and SHOULD NOT negotiate mechanisms that lack the GSS_C_MA_CBINDING_CONFIRM mechanism attribute (except if allowed by local configuration).</p><h3 id="rfc.section.2.5.1"><a href="#rfc.section.2.5.1">2.5.1</a>&nbsp;<a id="d1e606" href="#d1e606">C-Bindings</a></h3><p id="rfc.section.2.5.1.p.1">Because GSS_C_CHANNEL_BOUND_FLAG is a return flag only, and this flag is a request flag only, and to save on precious flag bits, we use the same flag bit assignment for both flags:</p><p id="rfc.section.2.5.1.p.3"> </p><div id="rfc.figure.u.4"></div><pre> #define GSS_C_CB_CONFIRM_FLAG 2048 /* 0x00000800 */</pre><hr class="noprint"><h1 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a>&nbsp;<a id="d1e622" href="#d1e622">Modified Channel Binding Semantics</a></h1><p id="rfc.section.3.p.1">The channel binding semantics of the base GSS-API are modified as follows:</p><p id="rfc.section.3.p.2"> </p><ul><li>Whenever both, the initiator and acceptor shall have provided input_channel_bindings to GSS_Init/Accept_sec_context() and the channel bindings do not match, then the mechanism MUST fail to establish a security context token. This is a restatement of an existing requirement in the base specification, restated for convenience.</li><li>Whenever the acceptor application shall have a) provided channel bindings to GSS_Accept_sec_context(), and b) not indicated support for the ret_channel_bound_flag flag, then the mechanism MUST fail to establish a security context if the initiator did not provide channel bindings data. This requirement is for security purposes, to make applications predating this document secure, and this requirement reflects actual implementations as deployed.</li><li>Whenever the initiator application shall have a) provided channel bindings to GSS_Init_sec_context(), and b) not indicated support for the ret_channel_bound_flag flag, then the mechanism SHOULD NOT fail to establish a security context just because the acceptor failed to provide channel bindings data. This recommendation is for interoperability purposes, and reflects actual implementations that have been deployed. It is possible that not all security mechanism protocols can implement this requirement easily.</li><li>Whenever the application shall have a) provided channel bindings to GSS_Init_sec_context() or GSS_Accept_sec_context(), and b) indicated support for the ret_channel_bound_flag flag, then the mechanism MUST NOT fail to establish a security context just because the peer did not provide channel bindings data. The mechanism MUST output the ret_channel_bound_flag if both peers provided the same input_channel_bindings to GSS_Init_sec_context() and GSS_Accept_sec_context. The mechanism MUST NOT output the ret_channel_bound_flag if either (or both) peer did not provide input_channel_bindings to GSS_Init/Accept_sec_context(). This requirement restores the original base GSS-API specified behavior, with the addition of the ret_channel_bound_flag flag</li></ul><hr class="noprint"><h1 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a>&nbsp;<a id="d1e644" href="#d1e644">Security Considerations</a></h1><p id="rfc.section.4.p.1">This document deals with security. There are no security considerations that should be documented separately in this section. To recap, this document fixes a significant flaw in the base GSS-API <a href="#RFC2743"><cite title="Generic Security Service Application Program Interface Version 2, Update 1">[RFC2743]</cite></a> specification that fortunately has not been implemented, and it adds a feature (that should have been in the base specification) for improved negotiation of use of channel binding <a href="#RFC5056"><cite title="On the Use of Channel Bindings to Secure Channels">[RFC5056]</cite></a>.</p><hr class="noprint"><h1 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a>&nbsp;<a id="d1e665" href="#d1e665">IANA Considerations</a></h1><p id="rfc.section.5.p.1">This document has no IANA considerations.</p><hr class="noprint"><h1 id="rfc.references" class="np"><a id="rfc.section.6" href="#rfc.section.6">6.</a> References</h1><h2 class="np" id="rfc.references.1"><a href="#rfc.section.6.1" id="rfc.section.6.1">6.1</a> Normative References</h2><table><tr><td class="reference"><b id="RFC2119">[RFC2119]</b></td><td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>&#8221;, BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.</td></tr><tr><td class="reference"><b id="RFC2743">[RFC2743]</b></td><td class="top"><a href="mailto:jlinn@rsasecurity.com" title="RSA Laboratories">Linn, J.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>&#8221;, RFC&nbsp;2743, January&nbsp;2000.</td></tr><tr><td class="reference"><b id="RFC2744">[RFC2744]</b></td><td class="top"><a href="mailto:John_Wray@Iris.com" title="Iris Associates">Wray, J.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2744">Generic Security Service API Version 2 : C-bindings</a>&#8221;, RFC&nbsp;2744, January&nbsp;2000.</td></tr><tr><td class="reference"><b id="RFC5056">[RFC5056]</b></td><td class="top">Williams, N., &#8220;<a href="http://tools.ietf.org/html/rfc5056">On the Use of Channel Bindings to Secure Channels</a>&#8221;, RFC&nbsp;5056, November&nbsp;2007.</td></tr><tr><td class="reference"><b id="RFC5587">[RFC5587]</b></td><td class="top">Williams, N., &#8220;<a href="http://tools.ietf.org/html/rfc5587">Extended Generic Security Service Mechanism Inquiry APIs</a>&#8221;, RFC&nbsp;5587, July&nbsp;2009.</td></tr></table><h2 id="rfc.references.2"><a href="#rfc.section.6.2" id="rfc.section.6.2">6.2</a> Informative References</h2><table><tr><td class="reference"><b id="RFC4121">[RFC4121]</b></td><td class="top">Zhu, L., Jaganathan, K., and S. Hartman, &#8220;<a href="http://tools.ietf.org/html/rfc4121">The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2</a>&#8221;, RFC&nbsp;4121, July&nbsp;2005.</td></tr><tr><td class="reference"><b id="RFC4178">[RFC4178]</b></td><td class="top">Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, &#8220;<a href="http://tools.ietf.org/html/rfc4178">The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism</a>&#8221;, RFC&nbsp;4178, October&nbsp;2005.</td></tr><tr><td class="reference"><b id="RFC5653">[RFC5653]</b></td><td class="top">Upadhyay, M. and S. Malkani, &#8220;<a href="http://tools.ietf.org/html/rfc5653">Generic Security Service API Version 2: Java Bindings Update</a>&#8221;, RFC&nbsp;5653, August&nbsp;2009.</td></tr><tr><td class="reference"><b id="I-D.williams-williams-kitten-ctx-simple-async">[I-D.williams-williams-kitten-ctx-simple-async]</b></td><td class="top">Williams, N., &#8220;<a href="http://tools.ietf.org/html/draft-williams-williams-kitten-ctx-simple-async-00">Simplified and Asynchronous Security Context Interfaces for the Generic Security Services Application Programming Interface</a>&#8221;, Internet-Draft&nbsp;draft-williams-williams-kitten-ctx-simple-async-00 (work in progress), February&nbsp;2013.</td></tr></table><hr class="noprint"><div class="avoidbreak"><h1 id="rfc.authors" class="np"><a href="#rfc.authors">Author's Address</a></h1><address class="vcard"><span class="vcardline"><span class="fn">Nicolas Williams</span><span class="n hidden"><span class="family-name">Williams</span><span class="given-name">Nicolas</span></span></span><span class="org vcardline">Cryptonector, LLC</span><span class="vcardline">EMail: <a href="mailto:nico@cryptonector.com"><span class="email">nico@cryptonector.com</span></a></span></address></div></body></html>