<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en"><head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/"><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>Channel Binding Signalling for the Generic Security Services Application Programming Interface</title><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: verdana, helvetica, arial, sans-serif;
  font-size: 10pt;
  margin-right: 2em;
}
cite {
  font-style: normal;
}
dl {
  margin-left: 2em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 14pt;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h1 a {
  color: #333333;
}
h2 {
  font-size: 12pt;
  line-height: 15pt;
  page-break-after: avoid;
}
h3, h4, h5, h6 {
  font-size: 10pt;
  page-break-after: avoid;
}
h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
}
ol {
  margin-left: 2em;
}
ol.la {
  list-style-type: lower-alpha;
}
ol.ua {
  list-style-type: upper-alpha;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
  page-break-inside: avoid;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
table {
  margin-left: 2em;
}
table.header {
  border-spacing: 1px;
  width: 95%;
  font-size: 10pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap; 
}
table.header td {
  background-color: gray;
  width: 50%;
}
table.header a {
  color: white;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc, ul.toc ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
}
ul.toc li {
  line-height: 150%;
  font-weight: bold;
  font-size: 10pt;
  margin-left: 0em;
}
ul.toc li li {
  line-height: normal;
  font-weight: normal;
  font-size: 9pt;
  margin-left: 0em;
}
li.excluded {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}

.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 9pt;
}
.filename {
  color: #333333;
  font-weight: bold;
  font-size: 12pt;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.hidden {
  display: none;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: #990000;
  font-size: 18pt;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.vcardline {
  display: block;
}
.warning {
  font-size: 14pt;
  background-color: yellow;
}


@media print {
  .noprint {
    display: none;
  }
  
  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 12pt;
  }

  ul.toc a::after {
    content: leader('.') target-counter(attr(href), page);
  }
  
  ul.ind li li a {
    content: target-counter(attr(href), page);
  }
  
  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "Internet-Draft"; 
  } 
  @top-right {
       content: "February 2013"; 
  } 
  @top-center {
       content: "GSS Channel Bound Flag"; 
  } 
  @bottom-left {
       content: "Williams"; 
  } 
  @bottom-center {
       content: "Expires August 15, 2013"; 
  } 
  @bottom-right {
       content: "[Page " counter(page) "]"; 
  } 
}

@page:first { 
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Channel Binding State Extension" href="#rfc.section.2"><link rel="Chapter" href="#rfc.section.3" title="3 References"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.580, 2012-06-03 11:18:18, XSLT vendor: SAXON 9.0.0.4 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dct" href="http://purl.org/dc/terms/"><meta name="dct.creator" content="Williams, N."><meta name="dct.identifier" content="urn:ietf:id:draft-williams-kitten-channel-bound-flag-00"><meta name="dct.issued" scheme="ISO8601" content="2013-02-11"><meta name="dct.abstract" content="This Internet-Draft proposes the addition of a &#8220;channel bound&#8221; return flag for the GSS_Init_sec_context() and GSS_Accept_sec_context() functions. Two behaviors are specified: a default, safe behavior, and a behavior that is only safe when the application specifically tells the Generic Security Services Application Programming Interface (GSS-API) that it (the applicaiton) supports the new behavior."><meta name="description" content="This Internet-Draft proposes the addition of a &#8220;channel bound&#8221; return flag for the GSS_Init_sec_context() and GSS_Accept_sec_context() functions. Two behaviors are specified: a default, safe behavior, and a behavior that is only safe when the application specifically tells the Generic Security Services Application Programming Interface (GSS-API) that it (the applicaiton) supports the new behavior."></head><body><table class="header"><tbody><tr><td class="left">Network Working Group</td><td class="right">N. Williams</td></tr><tr><td class="left">Internet-Draft</td><td class="right">Cryptonector</td></tr><tr><td class="left">Updates: RFC2743 RFC2744 (if approved)</td><td class="right">February 11, 2013</td></tr><tr><td class="left">Intended status: Standards Track</td><td class="right"></td></tr><tr><td class="left">Expires: August 15, 2013</td><td class="right"></td></tr></tbody></table><p class="title">Channel Binding Signalling for the Generic Security Services Application Programming Interface<br><span class="filename">draft-williams-kitten-channel-bound-flag-00</span></p><h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1><p>This Internet-Draft proposes the addition of a &#8220;channel bound&#8221; return flag for the GSS_Init_sec_context() and GSS_Accept_sec_context() functions. Two behaviors are specified: a default, safe behavior, and a behavior that is only safe when the application specifically tells the Generic Security Services Application Programming Interface (GSS-API) that it (the applicaiton) supports the new behavior.</p><h1><a id="rfc.status" href="#rfc.status">Status of this Memo</a></h1><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as &#8220;work in progress&#8221;.</p><p>This Internet-Draft will expire on August 15, 2013.</p><h1><a id="rfc.copyrightnotice" href="#rfc.copyrightnotice">Copyright Notice</a></h1><p>Copyright © 2013 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p><hr class="noprint"><h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1><ul class="toc"><li>1.&nbsp;&nbsp;&nbsp;<a href="#d1e208">Introduction</a><ul><li>1.1&nbsp;&nbsp;&nbsp;<a href="#d1e242">Error in RFC2743</a></li><li>1.2&nbsp;&nbsp;&nbsp;<a href="#d1e257">Conventions used in this document</a></li></ul></li><li>2.&nbsp;&nbsp;&nbsp;<a href="#d1e272">Channel Binding State Extension</a><ul><li>2.1&nbsp;&nbsp;&nbsp;<a href="#d1e296">GSS_Set_cred_option()</a><ul><li>2.1.1&nbsp;&nbsp;&nbsp;<a href="#d1e348">C-Bindings</a></li></ul></li><li>2.2&nbsp;&nbsp;&nbsp;<a href="#d1e379">GSS_Set_cred_option_critical()</a><ul><li>2.2.1&nbsp;&nbsp;&nbsp;<a href="#d1e434">C-Bindings</a></li></ul></li><li>2.3&nbsp;&nbsp;&nbsp;<a href="#d1e462">channel_bound_flag</a><ul><li>2.3.1&nbsp;&nbsp;&nbsp;<a href="#d1e475">C-Bindings</a></li></ul></li></ul></li><li>3.&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li>3.1&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li>3.2&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.authors">Author's Address</a></li></ul><ul class="toc"><li>Figures
        <ul><li><a href="#rfc.figure.1">Figure 1: </a></li><li><a href="#rfc.figure.2">Figure 2: </a></li><li><a href="#rfc.figure.3">Figure 3: </a></li></ul></li></ul><hr class="noprint"><h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a id="d1e208" href="#d1e208">Introduction</a></h1><p id="rfc.section.1.p.1">The GSS-API <a href="#RFC2743"><cite title="Generic Security Service Application Program Interface Version 2, Update 1">[RFC2743]</cite></a> supports &#8220;channel binding&#8221; <a href="#RFC5056"><cite title="On the Use of Channel Bindings to Secure Channels">[RFC5056]</cite></a>, a technique for detection of man-in-the-middle (MITM) attacks in secure channels at lower network layers. This facility is meant to be all-or-nothing: either both the initiator and acceptor use it and it succeeds, or both must not use it. This has created a negotiation problem when retrofitting the use of channel binding into existing application protocols.</p><p id="rfc.section.1.p.2">Many implementations of the Kerberos V5 GSS-API mechanism <a href="#RFC4121"><cite title="The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2">[RFC4121]</cite></a> cause the acceptor to succeed when the initiator used channel binding but the acceptor application did not. This has helped deployment of channel binding in existing applications: first fix all the initiators, then fix all the acceptors. But even this is insufficient when there are many clients to fix, such that fixing them all will take a long time.</p><p id="rfc.section.1.p.3">This document proposes a new method for deployment of channel binding that allows the feature to be enabled on the acceptor side before fixing all initiators. If the GSS-API had always had a return flag by which to indicate channel binding state then we could have had a simpler method of deploying channel binding: applications check that return flag and act accordingly (e.g., fail when channel binding is required). We cannot safely introduce this behavior now without an indication of support by the application.</p><h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a id="d1e242" href="#d1e242">Error in RFC2743</a></h2><p id="rfc.section.1.1.p.1">The GSS-APIv2u1 <a href="#RFC2743"><cite title="Generic Security Service Application Program Interface Version 2, Update 1">[RFC2743]</cite></a> seems to indicate that mechanisms must ignore channel bindings when one party provided none. In practice some mechanisms ignore channel bindings when the acceptor provides none, but not when the initiator provides none. Note that it would be useless to allow security context establishment to succeed when the initiator does not provide channel bindings but the acceptor does, at least as long as there's no outward indication of whether channel binding was used! And indeed, the GSS-APIv2u1 does not provide any such indication. We correct this flaw in this document.</p><h2 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2</a>&nbsp;<a id="d1e257" href="#d1e257">Conventions used in this document</a></h2><p id="rfc.section.1.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p><hr class="noprint"><h1 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a id="d1e272" href="#d1e272">Channel Binding State Extension</a></h1><p id="rfc.section.2.p.1">We propose a new return flag for GSS_Init_sec_context() and GSS_Accept_sec_context(), as well as a pair of functions for setting options on credential handles, along with an option for signalling understanding of the new flag in the acceptor applications.</p><p id="rfc.section.2.p.2">C bindings of these extensions are provided along the lines of <a href="#RFC2744"><cite title="Generic Security Service API Version 2 : C-bindings">[RFC2744]</cite></a> and <a href="#RFC5587"><cite title="Extended Generic Security Service Mechanism Inquiry APIs">[RFC5587]</cite></a>.</p><h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a id="d1e296" href="#d1e296">GSS_Set_cred_option()</a></h2><p id="rfc.section.2.1.p.1">Inputs:</p><p id="rfc.section.2.1.p.2"> </p><dl><dt>cred_handle&nbsp;CREDENTIAL&nbsp;HANDLE</dt><dd>If no credential handle is given then the option MAY be applied globally to the default credential handle, but the implementation MAY return an error instead.</dd><dt>desired_object&nbsp;OBJECT&nbsp;IDENTIFIER</dt><dd>Desired option; MUST NOT be GSS_C_NO_OID.</dd><dt>value&nbsp;OCTET&nbsp;STRING</dt><dd>Value for the option.</dd></dl><p id="rfc.section.2.1.p.3">Outputs:</p><p id="rfc.section.2.1.p.4"> </p><ul><li>major_status INTEGER</li><li>minor_status INTEGER</li></ul><p id="rfc.section.2.1.p.5">Return major status codes:</p><p id="rfc.section.2.1.p.6"> </p><ul><li>GSS_S_COMPLETE indicates success.</li><li>GSS_S_UNAVAILABLE indicates that the the given option is not supported by any mechanism.</li><li>GSS_S_FAILURE indicates a general failure.</li></ul><p id="rfc.section.2.1.p.7">This function sets the given value to a credential option named by desired_object on the given cred_handle.</p><h3 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1</a>&nbsp;<a id="d1e348" href="#d1e348">C-Bindings</a></h3><p id="rfc.section.2.1.1.p.2"> </p><div id="magicparlabel-137"></div><div id="rfc.figure.1"></div><pre>   OM_uint32
   gss_set_cred_option(OM_uint32 *minor_status,
                       gss_cred_id_t *cred_handle,
                       const gss_OID desired_object,
                       const gss_buffer_t value);</pre><p class="figure">Figure 1</p><p id="rfc.section.2.1.1.p.3">NOTE: the cred_handle input argument to gss_set_cred_option() is a pointer to gss_cred_id_t for historical reasons. This is in conflict with the regular GSS-API pattern, but it cannot be changed at this stage. [We could rename this function and not document gss_set_cred_option(), but what would be the point?]</p><h2 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a id="d1e379" href="#d1e379">GSS_Set_cred_option_critical()</a></h2><p id="rfc.section.2.2.p.1">Inputs:</p><p id="rfc.section.2.2.p.2"> </p><dl><dt>input_cred_handle&nbsp;CREDENTIAL&nbsp;HANDLE</dt><dd>If no credential handle is given then the option MAY be applied globally to the default credential handle, but the implementation MAY return an error instead.</dd><dt>desired_object&nbsp;OBJECT&nbsp;IDENTIFIER</dt><dd>Desired option; MUST NOT be GSS_C_NO_OID.</dd><dt>value&nbsp;OCTET&nbsp;STRING</dt><dd>Value for the option.</dd></dl><p id="rfc.section.2.2.p.3">Outputs:</p><p id="rfc.section.2.2.p.4"> </p><ul><li>output_cred_handle CREDENTIAL_HANDLE</li><li>major_status INTEGER</li><li>minor_status INTEGER</li></ul><p id="rfc.section.2.2.p.5">Return major status codes:</p><p id="rfc.section.2.2.p.6"> </p><ul><li>GSS_S_COMPLETE indicates success.</li><li>GSS_S_UNAVAILABLE indicates that the the given option is not supported by any mechanism.</li><li>GSS_S_FAILURE indicates a general failure.</li></ul><p id="rfc.section.2.2.p.7">This function sets the given value to a credential option named by desired_object on the given input_cred_handle or on a duplicate handle output in the output_cred_handle parameter if desired. If any mechanisms -for which the credential has elements- fails to set the option then that element will be removed from the credential.</p><h3 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1</a>&nbsp;<a id="d1e434" href="#d1e434">C-Bindings</a></h3><p id="rfc.section.2.2.1.p.2"> </p><div id="magicparlabel-172"></div><div id="rfc.figure.2"></div><pre>   OM_uint32
   gss_set_cred_option_critical(OM_uint32 *minor_status,
                                gss_const_cred_id_t input_cred_handle,
                                gss_cred_id_t *output_cred_handle,
                                const gss_OID desired_object,
                                const gss_buffer_t value);</pre><p class="figure">Figure 2</p><h2 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3</a>&nbsp;<a id="d1e462" href="#d1e462">channel_bound_flag</a></h2><p id="rfc.section.2.3.p.1">Whenever both the initiator and the acceptor provide matching channel bindings to GSS_Init_sec_context() and GSS_Accept_sec_context(), respectively, then the mechanism SHALL indicate that the context is channel bound via an output flag for the established context.</p><p id="rfc.section.2.3.p.2">Whenever the caller shall have set the GSS_C_CHANNEL_BOUND_CRED_OPT_OID (see below) then the mechanism SHOULD allow security context establishment to succeed even if one of the initiator or acceptor failed to provide channel bindings. Whenever the acceptor shall not have set GSS_C_CHANNEL_BOUND_CRED_OPT_OID (see below) and the acceptor has provided channel bindings, then the mechanism MUST NOT allow context establishment to succeed when the initiator has not itself provided channel bindings.</p><h3 id="rfc.section.2.3.1"><a href="#rfc.section.2.3.1">2.3.1</a>&nbsp;<a id="d1e475" href="#d1e475">C-Bindings</a></h3><p id="rfc.section.2.3.1.p.2"> </p><div id="magicparlabel-192"></div><div id="rfc.figure.3"></div><pre>   #define GSS_C_CHANNEL_BOUND 4096 /* 0x1000
   gss_const_OID GSS_C_CHANNEL_BOUND_CRED_OPT_OID; /* OID TBD */</pre><p class="figure">Figure 3</p><hr class="noprint"><h1 id="rfc.references" class="np"><a id="rfc.section.3" href="#rfc.section.3">3.</a> References</h1><h2 class="np" id="rfc.references.1"><a href="#rfc.section.3.1" id="rfc.section.3.1">3.1</a> Normative References</h2><table><tr><td class="reference"><b id="RFC2119">[RFC2119]</b></td><td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>&#8221;, BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.</td></tr><tr><td class="reference"><b id="RFC2743">[RFC2743]</b></td><td class="top"><a href="mailto:jlinn@rsasecurity.com" title="RSA Laboratories">Linn, J.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>&#8221;, RFC&nbsp;2743, January&nbsp;2000.</td></tr><tr><td class="reference"><b id="RFC2744">[RFC2744]</b></td><td class="top"><a href="mailto:John_Wray@Iris.com" title="Iris Associates">Wray, J.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2744">Generic Security Service API Version 2 : C-bindings</a>&#8221;, RFC&nbsp;2744, January&nbsp;2000.</td></tr><tr><td class="reference"><b id="RFC5056">[RFC5056]</b></td><td class="top">Williams, N., &#8220;<a href="http://tools.ietf.org/html/rfc5056">On the Use of Channel Bindings to Secure Channels</a>&#8221;, RFC&nbsp;5056, November&nbsp;2007.</td></tr><tr><td class="reference"><b id="RFC5587">[RFC5587]</b></td><td class="top">Williams, N., &#8220;<a href="http://tools.ietf.org/html/rfc5587">Extended Generic Security Service Mechanism Inquiry APIs</a>&#8221;, RFC&nbsp;5587, July&nbsp;2009.</td></tr></table><h2 id="rfc.references.2"><a href="#rfc.section.3.2" id="rfc.section.3.2">3.2</a> Informative References</h2><table><tr><td class="reference"><b id="RFC4121">[RFC4121]</b></td><td class="top">Zhu, L., Jaganathan, K., and S. Hartman, &#8220;<a href="http://tools.ietf.org/html/rfc4121">The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2</a>&#8221;, RFC&nbsp;4121, July&nbsp;2005.</td></tr></table><hr class="noprint"><div class="avoidbreak"><h1 id="rfc.authors" class="np"><a href="#rfc.authors">Author's Address</a></h1><address class="vcard"><span class="vcardline"><span class="fn">Nicolas Williams</span><span class="n hidden"><span class="family-name">Williams</span><span class="given-name">Nicolas</span></span></span><span class="org vcardline">Cryptonector, LLC</span><span class="vcardline">EMail: <a href="mailto:nico@cryptonector.com"><span class="email">nico@cryptonector.com</span></a></span></address></div></body></html>